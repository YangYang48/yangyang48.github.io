<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码 on 欢迎来到我的博客~</title>
    <link>https://yangyang48.github.io/tags/%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in 源码 on 欢迎来到我的博客~</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yangyang48.github.io/tags/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal之子父线程的恩爱情仇</title>
      <link>https://yangyang48.github.io/2022/04/threadlocal%E4%B9%8B%E5%AD%90%E7%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%81%A9%E7%88%B1%E6%83%85%E4%BB%87/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/04/threadlocal%E4%B9%8B%E5%AD%90%E7%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%81%A9%E7%88%B1%E6%83%85%E4%BB%87/</guid>
      <description>&lt;p&gt;我们知道Thread中会维护两个ThreadLocalMap，这个时候如果同时存在子父线程，子线程该如何获取父线程ThreadLocal的值&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HIDL介绍和使用</title>
      <link>https://yangyang48.github.io/2022/03/hidl%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/03/hidl%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;AIDL并不是唯一的Binder的应用，除了AIDL还有一个经常在HAL层代码中出现的HIDL。本文就是通过HIDL展开描述，主要对于AIDL的介绍和使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ByteBuffer使用</title>
      <link>https://yangyang48.github.io/2022/02/bytebuffer%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/02/bytebuffer%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;ByteBuffer，一个字节缓冲区。我们通常通过这类缓冲区(Buffer)在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parcel1 Parcel和Parcelable源码分析</title>
      <link>https://yangyang48.github.io/2022/02/parcel1-parcel%E5%92%8Cparcelable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/02/parcel1-parcel%E5%92%8Cparcelable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;Intent数据会作为Parcel被存储在Binder事务缓冲区中的对象进行传输。Parcel作为Android底层IPC通信的基础，熟悉Parcel作为了解Binder的第一步。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AIDL2 源码分析</title>
      <link>https://yangyang48.github.io/2021/11/aidl2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/aidl2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;aidl一种android接口描述语言，本文主要是对.aidl文件自动生成的.java文件的具体源码进行分析，描述AIDL生成的java类细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ThreadLocal之初出茅庐</title>
      <link>https://yangyang48.github.io/2021/11/threadlocal%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/threadlocal%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</guid>
      <description>&lt;p&gt;我们使用ThreadLocal能够解决线程局部变量统一定义问题，多线程数据不能共享的问题，使得每一个线程单独维护自己线程内的变量值（set、get、remove）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler1-消息传递机制</title>
      <link>https://yangyang48.github.io/2021/08/handler1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;Handler是一个优秀的内存共享方案。其内存管理和设计思路相当完整。
通过Handler来通知UI组件更新或者是处理对应消息。那么Handler消息机制是什么？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler2 Thread</title>
      <link>https://yangyang48.github.io/2021/08/handler2-thread/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler2-thread/</guid>
      <description>&lt;p&gt;Android是基于事件驱动的，即所有的不管是Activity、Service生命周期都是通过handler事件驱动的。
那么Handler内部的线程是如何管理而且还能够保证安全。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler3 同步屏障</title>
      <link>https://yangyang48.github.io/2021/08/handler3-%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler3-%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</guid>
      <description>&lt;p&gt;学习Handler之后，通常会出现同步屏障的字样。MessageQueue管理优先级队列的过程中，如果消息存在一种“紧急”消息，
需要更高的优先级处理，这个时候就需要同步屏障。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler4 HandlerThread</title>
      <link>https://yangyang48.github.io/2021/08/handler4-handlerthread/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler4-handlerthread/</guid>
      <description>&lt;p&gt;开发中我们需要去执行多个任务，且要求按顺序执行。如果使用多线程，有多个任务就多创建几个线程实现，这时候可能出现线程同步的问题。
如果需要管理这些线程，可以考虑使用HandlerThread。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler5 IntentService</title>
      <link>https://yangyang48.github.io/2021/08/handler5-intentservice/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler5-intentservice/</guid>
      <description>&lt;p&gt;在Android开发中，需要在后台执行异步耗时请求，而且存在很多这种请求，那么怎么管理这些请求。
如果不断的创建线程，本身就非常耗性能，且不易管理，这个时候可以考虑使用IntentService。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
