<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.85.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Yang Ju">
<meta name="keywords" content="">
<meta name="description" content="我们通常用ioctl函数直接访问到内核，在内核执行操作，执行读写操作。那么这个函数指令的原理是什么，本文就展开介绍和使用一下ioctl。">


<meta property="og:description" content="我们通常用ioctl函数直接访问到内核，在内核执行操作，执行读写操作。那么这个函数指令的原理是什么，本文就展开介绍和使用一下ioctl。">
<meta property="og:type" content="article">
<meta property="og:title" content="ioctl通信方式之初出茅庐">
<meta name="twitter:title" content="ioctl通信方式之初出茅庐">
<meta property="og:url" content="https://yangyang48.github.io/2022/07/ioctl%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/">
<meta property="twitter:url" content="https://yangyang48.github.io/2022/07/ioctl%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/">
<meta property="og:site_name" content="欢迎来到我的博客~">
<meta property="og:description" content="我们通常用ioctl函数直接访问到内核，在内核执行操作，执行读写操作。那么这个函数指令的原理是什么，本文就展开介绍和使用一下ioctl。">
<meta name="twitter:description" content="我们通常用ioctl函数直接访问到内核，在内核执行操作，执行读写操作。那么这个函数指令的原理是什么，本文就展开介绍和使用一下ioctl。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2022-07-24T00:00:00">
  
  
    <meta property="article:modified_time" content="2022-07-24T00:00:00">
  
  
  
    
      <meta property="article:section" content="ioctl">
    
      <meta property="article:section" content="2022">
    
      <meta property="article:section" content="July">
    
  
  
    
      <meta property="article:tag" content="kernel">
    
      <meta property="article:tag" content="软中断">
    
      <meta property="article:tag" content="系统调用表">
    
      <meta property="article:tag" content="用户与驱动之间的协议">
    
      <meta property="article:tag" content="驱动">
    
      <meta property="article:tag" content="Android">
    
      <meta property="article:tag" content="源码">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://yangyang48.github.io/ioctl/ioctl_thumb.jpg">
  <meta property="twitter:image" content="https://yangyang48.github.io/ioctl/ioctl_thumb.jpg">


  <meta property="og:image" content="https://yangyang48.github.io/ioctl/ioctl_cover.jpg">
  <meta property="twitter:image" content="https://yangyang48.github.io/ioctl/ioctl_cover.jpg">




  <meta property="og:image" content="https://yangyang48.github.io/thumb/20210711204627625.jpg">
  <meta property="twitter:image" content="https://yangyang48.github.io/thumb/20210711204627625.jpg">


    <title>ioctl通信方式之初出茅庐</title>

    <link rel="icon" href="https://yangyang48.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://yangyang48.github.io/2022/07/ioctl%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://yangyang48.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://yangyang48.github.io/css/copy-to-clipboard.css">
      
    

    
      
    
    

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://yangyang48.github.io/">欢迎来到我的博客~</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://yangyang48.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://yangyang48.github.io/#about">
          <img class="sidebar-profile-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Yang Ju</h4>
        
          <h5 class="sidebar-profile-bio">Nanjing University of Science and Technology</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/YangYang48" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://blog.csdn.net/yangju147532896" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-chain"></i>
      
      <span class="sidebar-button-desc">CSDN</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              "
       style="background-image:url('/ioctl/ioctl_cover.jpg')"
       data-behavior="4">
    
  </div>


      <div id="main" data-behavior="4"
        class="hasCover
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      ioctl通信方式之初出茅庐
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2022-07-24T00:00:00Z">
        
  七月 24, 2022

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://yangyang48.github.io/categories/ioctl">ioctl</a>, 
    
      <a class="category-link" href="https://yangyang48.github.io/categories/2022">2022</a>, 
    
      <a class="category-link" href="https://yangyang48.github.io/categories/july">July</a>
    
  

  </div>

</div>
          
		  
		  <h5 id="wc" style="font-size: 1rem;text-align: center;">2700 Words|Read in about 13 Min|本文总阅读量<span id="busuanzi_value_page_pv"></span>次</h5>
      
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>我们通常用ioctl函数直接访问到内核，在内核执行操作，执行读写操作。那么这个函数指令的原理是什么，本文就展开介绍和使用一下ioctl。</p>
<h1 id="1ioctl简介">1ioctl简介</h1>
<h2 id="11什么是ioctl">1.1什么是ioctl</h2>
<blockquote>
<p>从ioctl这个名称上看，它是设备驱动程序中对设备的I/O通道进行管理的函数。</p>
<p>所谓对I/O通道进行管理，就是对设备的一些特性进行控制。例如串口的传输波特率、马达的转速等等, 但实际上<strong>ioctl所处理的对象并不限制是真正的I/O设备</strong>，还可以是其它任何一个内核设备。</p>
</blockquote>
<p>说白了，ioctl以系统调用的形式提供了一<strong>条用户与内核交互的便捷途径</strong>。ioctl 这种方式的特点是用户层为主动，当用户层通过ioctl下发指令，内核给出相应的操作，具体的细节由自己实现的代码决定。</p>
<h2 id="12-基本原理">1.2 基本原理</h2>
<p>kernel3.0之前，叫ioctl，之后改名为unlocked_ioctl。功能和接口基本相同，名字发生了变化</p>
<p>ioctl既可以往内核读也可以写，read/write在执行大数据量读/写时比较有优势。</p>
<p>在应用层调用ioctl函数时，内核会调用对应驱动中的unlocked_ioctl函数，向内核读写数据。</p>
<p>笔者这里的kernel直接参考<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?h=v5.19-rc7">最新</a>的kernel-v5.19源码来分析。</p>
<p>内核实现ioctl()函数的是sys_ioctl()。内核中主要调用框架图如下图1所示</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/ioctl/ioctl_4.png" title="图1 内核中主要调用框架图" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/ioctl/ioctl_4.png"  alt="图1 内核中主要调用框架图">
  
    </a>
  
   
    <span class="caption">图1 内核中主要调用框架图</span>
  
</div>

<blockquote>
<p>至于为什么在驱动层中还会看到<code>compat_ioctl</code></p>
<p>这是因为为了<strong>相容性</strong>而出现的<code>compat_ioctl</code>。为了让32-bit的进程可以在64-bit上的system来执行ioctl这个函数。</p>
</blockquote>
<h1 id="2通信流程">2通信流程</h1>
<h2 id="21调用用户态的ioctl函数">2.1调用用户态的ioctl函数</h2>
<p>在用户态只有函数的声明，最终的实现是在内核态，也就是内核态封装了一个函数可以用于用户态的调用。</p>
<p>驱动程序中的ioctl属于内核空间，然而应用程序属于用户空间，没有权限访问内核空间，那么需要系统需要从用户态转为内核态，在系统调用中，是通过**<code>SWI</code>(Software Interrupt)的方式**陷入内核态的，这里实际上是一个靠**软中断**实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//development/ndk/platforms/android-30/include/sys/ioctl.h
</span><span class="ln">2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">ioctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...)</span> <span class="p">;</span>
</code></pre></div><h2 id="22在系统调用表中找到ioctl函数对应的函数名">2.2在系统调用表中找到ioctl函数对应的函数名</h2>
<h3 id="221ioctl的驱动定义">2.2.1ioctl的驱动定义</h3>
<p>首先找到定义的位置</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/uapi/asm-generic/unistd.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#ifndef __SYSCALL
</span><span class="ln"> 3</span><span class="cp">#define __SYSCALL(x, y)
</span><span class="ln"> 4</span><span class="cp">#endif
</span><span class="ln"> 5</span><span class="cp"></span>
<span class="ln"> 6</span><span class="cp">#if __BITS_PER_LONG == 32 || defined(__SYSCALL_COMPAT)
</span><span class="ln"> 7</span><span class="cp">#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _32)
</span><span class="ln"> 8</span><span class="cp">#else
</span><span class="ln"> 9</span><span class="cp">#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _64)
</span><span class="ln">10</span><span class="cp">#endif
</span><span class="ln">11</span><span class="cp"></span>
<span class="ln">12</span><span class="cp">#ifdef __SYSCALL_COMPAT
</span><span class="ln">13</span><span class="cp">#define __SC_COMP(_nr, _sys, _comp) __SYSCALL(_nr, _comp)
</span><span class="ln">14</span><span class="cp">#define __SC_COMP_3264(_nr, _32, _64, _comp) __SYSCALL(_nr, _comp)
</span><span class="ln">15</span><span class="cp">#else
</span><span class="ln">16</span><span class="cp">#define __SC_COMP(_nr, _sys, _comp) __SYSCALL(_nr, _sys)
</span><span class="ln">17</span><span class="cp">#define __SC_COMP_3264(_nr, _32, _64, _comp) __SC_3264(_nr, _32, _64)
</span><span class="ln">18</span><span class="cp">#endif
</span><span class="ln">19</span><span class="cp"></span>
<span class="ln">20</span><span class="cm">/* fs/ioctl.c */</span>
<span class="ln">21</span><span class="cp">#define __NR_ioctl 29
</span><span class="ln">22</span><span class="cp"></span><span class="n">__SC_COMP</span><span class="p">(</span><span class="n">__NR_ioctl</span><span class="p">,</span> <span class="n">sys_ioctl</span><span class="p">,</span> <span class="n">compat_sys_ioctl</span><span class="p">)</span>
</code></pre></div><p>因为这里边的宏定义比较多，直接替换掉宏定义</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/include/uapi/asm-generic/unistd.h
</span><span class="ln">2</span><span class="c1"></span><span class="n">__SYSCALL</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="n">sys_ioctl</span><span class="p">)</span>
</code></pre></div><h3 id="222系统调用表">2.2.2系统调用表</h3>
<p>系统调用表数组如下。如何解读系统调用表的用法，可以参考<a href="https://www.cnblogs.com/hazir/p/array_initialization.html">这里</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/arch/arc/kernel/sys.c
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define __SYSCALL(nr, call) [nr] = (call),
</span><span class="ln">3</span><span class="cp"></span>
<span class="ln">4</span><span class="kt">void</span><span class="o">*</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">NR_syscalls</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">5</span>    <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">NR_syscalls</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_ni_syscall</span><span class="p">,</span>
<span class="ln">6</span>    <span class="cp">#include</span><span class="cpf">&lt;asm/unistd.h&gt;</span><span class="cp">
</span><span class="ln">7</span><span class="cp"></span><span class="p">};</span>
</code></pre></div><p>这里用的是c99的语法规则，其中数组初始化可以用[0 &hellip; n]，这种写法。举例如下</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span> <span class="p">};</span>
<span class="ln">2</span><span class="c1">//或者写成：
</span><span class="ln">3</span><span class="c1">//省略到索引与值之间的=，GCC 2.5 之后该用法已经过时了，但 GCC 仍然支持
</span><span class="ln">4</span><span class="c1"></span><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="mi">29</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">15</span> <span class="p">};</span>     
<span class="ln">5</span><span class="c1">//两者均等价于：
</span><span class="ln">6</span><span class="c1"></span><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</code></pre></div><p>直到对应的语法之后，其中<code>#include&lt;asm/unistd.h&gt;</code>就是罗列了所有的系统调用函数名。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//所以得到的ioctl函数就是下面这个宏定义
</span><span class="ln"> 2</span><span class="c1"></span><span class="n">__SYSCALL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sys_io_setup</span><span class="p">)</span>
<span class="ln"> 3</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sys_io_destroy</span><span class="p">)</span>
<span class="ln"> 4</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sys_io_submit</span><span class="p">)</span>
<span class="ln"> 5</span><span class="p">...</span>
<span class="ln"> 6</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="n">sys_ioctl</span><span class="p">)</span>
<span class="ln"> 7</span><span class="p">...</span>
<span class="ln"> 8</span><span class="c1">//展开上述的宏定义
</span><span class="ln"> 9</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_io_setup</span><span class="p">,</span>
<span class="ln">10</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_io_destroy</span><span class="p">,</span>
<span class="ln">11</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_io_submit</span><span class="p">,</span>
<span class="ln">12</span><span class="p">...</span>
<span class="ln">13</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_ioctl</span><span class="p">,</span>
<span class="ln">14</span><span class="p">...</span>
</code></pre></div><ol>
<li>
<p>其中，<code>NR_syscalls</code>这个数是在<code>#include&lt;asm/unistd.h&gt;</code>中实际的系统调用函数名数量，比如435。那么<code>NR_syscalls</code>就会被435替换。</p>
</li>
<li>
<p>这个<code>sys_call_table</code>数组中的[0 &hellip; 434]是用于初始化的操作，其中这个<code>sys_ni_syscall</code>函数名返回的是<code>-ENOSYS</code>，说明如果没有找到<code>#include&lt;asm/unistd.h&gt;</code>中对应的函数，直接返回系统调用表初始化错误。</p>
</li>
<li>
<p>后面的操作，是相当于对其重新赋值，让每一个系统调用表数组都能够对应一个函数名，那么在找这个函数名的过程，只需要记住这个函数名在表中对应的序号即可，这里的ioctl函数，对应的就是29序号。即在系统调用表中找到ioctl函数对应的函数名为sys_ioctl。</p>
</li>
</ol>
<p>那么现在替换之后再来看系统调用表</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/arch/arc/kernel/sys.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#define __SYSCALL(nr, call) [nr] = (call),
</span><span class="ln"> 3</span><span class="cp"></span>
<span class="ln"> 4</span><span class="kt">void</span><span class="o">*</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="mi">435</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 5</span>    <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="mi">434</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_ni_syscall</span><span class="p">,</span>
<span class="ln"> 6</span>    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_restart_syscall</span><span class="p">,</span>
<span class="ln"> 7</span>    <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_exit</span><span class="p">,</span>
<span class="ln"> 8</span>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_fork</span><span class="p">,</span>
<span class="ln"> 9</span>    <span class="p">...</span>
<span class="ln">10</span>    <span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_ioctl</span><span class="p">,</span>
<span class="ln">11</span>    <span class="p">...</span>
<span class="ln">12</span><span class="p">};</span>
</code></pre></div><blockquote>
<p>关于<code>system_call</code>系统调用</p>
<p>因为上述得到的是系统调用表，而系统调用需要在这个系统调用表中查询。</p>
<p>通过软中断引发一个异常促使系统切换到内核去执行异常处理程序。该异常处理程序实际就是系统调用处理程序。这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序&mdash;-系统调用处理程序。系统调用处理程序叫<code>system_call()</code>，它与硬件体系结构紧密相关，用汇编语言编写。</p>
<p>应用程序告诉内核自己需要执行一个系统调用时，通知内核的机制是靠<code>system_call</code>函数通过将给定的系统调用号（<code>eax</code>的值）与<code>NR_syscalls</code>做比较来检查其有效性（<code>eax</code>代表寄存器）。如果它大于或等于<code>NR_syscalls</code>，该函数返回<code>-ENOSYS</code>。否则执行相应的系统调用：<code>call *sys_call_table(,%eax,4)</code>。由于系统调用表中的表项是以32位（4字节）类型存放的，所以内核需要将给定的系统调用号乘以4。</p>
<p>除了系统调用号以外，大部分系统调用都还需要一些外部的参数输入，所以需要把<strong>这些参数从用户空间传给内核</strong>。最简单的方法就是像传递系统调用参数那样也存放在寄存器里。</p>
</blockquote>
<p>对应的系统调用流程如下</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/ioctl/ioctl_1.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/ioctl/ioctl_1.png" >
  
    </a>
  
  
</div>

<h2 id="23找到内核中对应的函数指针">2.3找到内核中对应的函数指针</h2>
<p>找到了函数名<code>sys_ioctl</code>，就要去找对应的定义和实现</p>
<h3 id="231ioctl系统调用函数名定义">2.3.1ioctl系统调用函数名定义</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/include/linux/syscalls.h
</span><span class="ln">2</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
</code></pre></div><h3 id="232ioctl系统调用函数名实现">2.3.2ioctl系统调用函数名实现</h3>
<p>找到了这个定义之后，去找到实现。不过多了一个file结构体指针参数，可以将用户传递的<code>fd</code>转换为系统调用到内核内部<code>file</code>结构指针。当当前文件描述符表仅用于单个任务时，<code>fget_light()</code> / <code>fput_light()</code>不会触及引用计数。有关更多信息，请访问<a href="http://www.mjmwired.net/kernel/Documentation/filesystems/files.txt">read this</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/fs/ioctl.c
</span><span class="ln"> 2</span><span class="c1">//实际上SYSCALL_DEFINE3就是sys_ioctl
</span><span class="ln"> 3</span><span class="c1"></span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
<span class="ln"> 6</span>	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
<span class="ln"> 7</span>	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span><span class="c1">//由fd得带filp指针
</span><span class="ln">10</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span>
<span class="ln">11</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">12</span>
<span class="ln">13</span>	<span class="n">error</span> <span class="o">=</span> <span class="n">security_file_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="ln">14</span>	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="ln">15</span>		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
<span class="ln">16</span>
<span class="ln">17</span>	<span class="n">error</span> <span class="o">=</span> <span class="n">do_vfs_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="ln">18</span> <span class="nl">out_fput</span><span class="p">:</span>
<span class="ln">19</span>	<span class="n">fput_light</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="ln">20</span> <span class="nl">out</span><span class="p">:</span>
<span class="ln">21</span>	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="ln">22</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>补充说明:<strong>为什么<code>SYSCALL_DEFINE3</code>就是<code>sys_ioctl</code></strong>。</p>
<p>实际上这里的3代表有三个参数的意思，具体拆解可以点击<a href="https://blog.csdn.net/weixin_43798887/article/details/118930476">这里</a>，找到宏定义是如何一步步展开的，这里简单阐述。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/linux/syscalls.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define SYSCALL_DEFINE3(name, ...)  SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
</span><span class="ln">3</span><span class="cp">#define SYSCALL_DEFINEx(x, sname, ...)	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
</span><span class="ln">4</span><span class="cp">#define __SYSCALL_DEFINEx(x, name, ...)	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))
</span></code></pre></div><p><code>__SYSCALL_DEFINEx</code>宏定义</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//include/linux/syscalls.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#define __SYSCALL_DEFINEx(x, name, ...)					\
</span><span class="ln"> 3</span><span class="cp">	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__));		\
</span><span class="ln"> 4</span><span class="cp">	static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__));	\
</span><span class="ln"> 5</span><span class="cp">	asmlinkage long SyS##name(__SC_LONG##x(__VA_ARGS__))		\
</span><span class="ln"> 6</span><span class="cp">	{								\
</span><span class="ln"> 7</span><span class="cp">		__SC_TEST##x(__VA_ARGS__);				\
</span><span class="ln"> 8</span><span class="cp">		return (long) SYSC##name(__SC_CAST##x(__VA_ARGS__));	\
</span><span class="ln"> 9</span><span class="cp">	}								\
</span><span class="ln">10</span><span class="cp">	SYSCALL_ALIAS(sys##name, SyS##name);				\
</span><span class="ln">11</span><span class="cp">	static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__))
</span></code></pre></div><p><code>SYSCALL_ALIAS</code>定义</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/linux/syscalls.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define SYSCALL_ALIAS(alias, name)					\
</span><span class="ln">3</span><span class="cp">	asm (&#34;\t.globl &#34; #alias &#34;\n\t.set &#34; #alias &#34;, &#34; #name &#34;\n&#34;	\
</span><span class="ln">4</span><span class="cp">	     &#34;\t.globl .&#34; #alias &#34;\n\t.set .&#34; #alias &#34;, .&#34; #name)
</span></code></pre></div><p><code>__SC_DECL3</code>定义</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/linux/syscalls.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define __SC_DECL1(t1, a1)      t1 a1
</span><span class="ln">3</span><span class="cp">#define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
</span><span class="ln">4</span><span class="cp">#define __SC_DECL3(t3, a3, ...) t3 a3, __SC_DECL2(__VA_ARGS__)
</span></code></pre></div><p>展开所有的宏定义之后，得到结果</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>		\
<span class="ln"> 2</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">SYSC_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>	\
<span class="ln"> 3</span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">SyS_ioctl</span><span class="p">(</span><span class="kt">long</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>		\
<span class="ln"> 4</span><span class="p">{</span>								\
<span class="ln"> 5</span>    <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span> <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>               <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>				\
<span class="ln"> 6</span>    <span class="k">return</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">SYSC_ioctl</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>	\
<span class="ln"> 7</span><span class="p">}</span>								\
<span class="ln"> 8</span>    <span class="n">SYSCALL_ALIAS</span><span class="p">(</span><span class="n">sys_ioctl</span><span class="p">,</span> <span class="n">SyS_ioctl</span><span class="p">);</span>				\
<span class="ln"> 9</span>    <span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">SYSC_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="ln">10</span><span class="p">{</span>
<span class="ln">11</span>    <span class="n">code</span><span class="p">...</span>
<span class="ln">12</span><span class="p">}</span>
</code></pre></div><p>其实里面做的工作，就是将系统调用的参数统一变为了<strong>使用long类型来接收，然后再强转为本来参数类型</strong>。据说这样折腾是为了修复一个漏洞来的。</p>
</blockquote>
<h3 id="233struct-file结构体">2.3.3struct file结构体</h3>
<blockquote>
<p><strong>struct file</strong></p>
<p>这里的结构体相对比较复杂，我们只关注相关的结构体即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/linux/fs.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
<span class="ln"> 3</span>	<span class="k">union</span> <span class="p">{</span>
<span class="ln"> 4</span>		<span class="k">struct</span> <span class="n">llist_node</span>	<span class="n">fu_llist</span><span class="p">;</span>
<span class="ln"> 5</span>		<span class="k">struct</span> <span class="n">rcu_head</span> 	<span class="n">fu_rcuhead</span><span class="p">;</span>
<span class="ln"> 6</span>	<span class="p">}</span> <span class="n">f_u</span><span class="p">;</span>
<span class="ln"> 7</span>	<span class="k">struct</span> <span class="n">path</span>		<span class="n">f_path</span><span class="p">;</span>
<span class="ln"> 8</span>	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">f_inode</span><span class="p">;</span>	<span class="cm">/* cached value */</span>
<span class="ln"> 9</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
<span class="ln">10</span>
<span class="ln">11</span>	<span class="cm">/*
</span><span class="ln">12</span><span class="cm">	 * Protects f_ep, f_flags.
</span><span class="ln">13</span><span class="cm">	 * Must not be taken from IRQ context.
</span><span class="ln">14</span><span class="cm">	 */</span>
<span class="ln">15</span>	<span class="n">spinlock_t</span>		<span class="n">f_lock</span><span class="p">;</span>
<span class="ln">16</span>	<span class="n">atomic_long_t</span>		<span class="n">f_count</span><span class="p">;</span>
<span class="ln">17</span>	<span class="kt">unsigned</span> <span class="kt">int</span> 		<span class="n">f_flags</span><span class="p">;</span>
<span class="ln">18</span>	<span class="n">fmode_t</span>			<span class="n">f_mode</span><span class="p">;</span>
<span class="ln">19</span>	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">f_pos_lock</span><span class="p">;</span>
<span class="ln">20</span>	<span class="n">loff_t</span>			<span class="n">f_pos</span><span class="p">;</span>
<span class="ln">21</span>	<span class="k">struct</span> <span class="n">fown_struct</span>	<span class="n">f_owner</span><span class="p">;</span>
<span class="ln">22</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span>	<span class="o">*</span><span class="n">f_cred</span><span class="p">;</span>
<span class="ln">23</span>	<span class="k">struct</span> <span class="n">file_ra_state</span>	<span class="n">f_ra</span><span class="p">;</span>
<span class="ln">24</span>
<span class="ln">25</span>	<span class="n">u64</span>			<span class="n">f_version</span><span class="p">;</span>
<span class="ln">26</span><span class="cp">#ifdef CONFIG_SECURITY
</span><span class="ln">27</span><span class="cp"></span>	<span class="kt">void</span>			<span class="o">*</span><span class="n">f_security</span><span class="p">;</span>
<span class="ln">28</span><span class="cp">#endif
</span><span class="ln">29</span><span class="cp"></span>	<span class="cm">/* needed for tty driver, and maybe others */</span>
<span class="ln">30</span>	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
<span class="ln">31</span>
<span class="ln">32</span><span class="cp">#ifdef CONFIG_EPOLL
</span><span class="ln">33</span><span class="cp"></span>	<span class="cm">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
<span class="ln">34</span>	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="o">*</span><span class="n">f_ep</span><span class="p">;</span>
<span class="ln">35</span><span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_EPOLL */</span><span class="cp">
</span><span class="ln">36</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">f_mapping</span><span class="p">;</span>
<span class="ln">37</span>	<span class="n">errseq_t</span>		<span class="n">f_wb_err</span><span class="p">;</span>
<span class="ln">38</span>	<span class="n">errseq_t</span>		<span class="n">f_sb_err</span><span class="p">;</span> <span class="cm">/* for syncfs */</span>
<span class="ln">39</span><span class="p">}</span> <span class="n">__randomize_layout</span>
<span class="ln">40</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>	<span class="cm">/* lest something weird decides that 2 is OK */</span>
</code></pre></div></blockquote>
<h2 id="24与自定义的ioctl函数对应">2.4与自定义的ioctl函数对应</h2>
<h3 id="241do_vfs_ioctl">2.4.1do_vfs_ioctl</h3>
<p><code>sys_ioctl</code>函数调用之后，会走到最关键的函数<code>do_vfs_ioctl</code>。这里面会对传入的cmd进行拆解，默认的cmd有下面几种，这些都是<strong>预定义的</strong>，这些命令会被当作预定义命令被内核处理而不是被<strong>设备驱动</strong>处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/fs/ioctl.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">do_vfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
<span class="ln"> 3</span>	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6</span>	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="ln"> 7</span>	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10</span>	<span class="k">case</span> <span class="nl">FIOCLEX</span><span class="p">:</span>
<span class="ln">11</span>		<span class="n">set_close_on_exec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">12</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">13</span>
<span class="ln">14</span>	<span class="k">case</span> <span class="nl">FIONCLEX</span><span class="p">:</span>
<span class="ln">15</span>		<span class="n">set_close_on_exec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">16</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">17</span>
<span class="ln">18</span>	<span class="k">case</span> <span class="nl">FIONBIO</span><span class="p">:</span>
<span class="ln">19</span>		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fionbio</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
<span class="ln">20</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">21</span>
<span class="ln">22</span>	<span class="k">case</span> <span class="nl">FIOASYNC</span><span class="p">:</span>
<span class="ln">23</span>		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fioasync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
<span class="ln">24</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">25</span>
<span class="ln">26</span>	<span class="k">case</span> <span class="nl">FIOQSIZE</span><span class="p">:</span>
<span class="ln">27</span>		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">28</span>		    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">29</span>			<span class="n">loff_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">inode_get_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="ln">30</span>			<span class="n">error</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">res</span><span class="p">))</span> <span class="o">?</span>
<span class="ln">31</span>					<span class="o">-</span><span class="nl">EFAULT</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">32</span>		<span class="p">}</span> <span class="k">else</span>
<span class="ln">33</span>			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="ln">34</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">35</span>
<span class="ln">36</span>	<span class="k">case</span> <span class="nl">FIFREEZE</span><span class="p">:</span>
<span class="ln">37</span>		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fsfreeze</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="ln">38</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">39</span>
<span class="ln">40</span>	<span class="k">case</span> <span class="nl">FITHAW</span><span class="p">:</span>
<span class="ln">41</span>		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fsthaw</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="ln">42</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">43</span>
<span class="ln">44</span>	<span class="k">case</span> <span class="nl">FS_IOC_FIEMAP</span><span class="p">:</span>
<span class="ln">45</span>		<span class="k">return</span> <span class="n">ioctl_fiemap</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="ln">46</span>
<span class="ln">47</span>	<span class="k">case</span> <span class="nl">FIGETBSZ</span><span class="p">:</span>
<span class="ln">48</span>		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
<span class="ln">49</span>
<span class="ln">50</span>	<span class="k">default</span><span class="o">:</span>
<span class="ln">51</span>		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span><span class="c1">//是否为常规文件若是常规文件
</span><span class="ln">52</span><span class="c1"></span>			<span class="n">error</span> <span class="o">=</span> <span class="n">file_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="ln">53</span>		<span class="k">else</span>
<span class="ln">54</span>			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span><span class="c1">//调用vfs_ioctl
</span><span class="ln">55</span><span class="c1"></span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">56</span>	<span class="p">}</span>
<span class="ln">57</span>	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="ln">58</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>补充说明</p>
<p>以下的ioctl命令对任何文件都是预定义的(<strong>属于内核系统级的预定义</strong>)</p>
<p>前面的五个预定义根据下面的2.5的协议，可以知道，实际上是0x54代表type为**‘T’**</p>
<ul>
<li><strong>FIOCLEX</strong></li>
</ul>
<p>设置执行时关闭标志(File IOctl CLose on Exec)。设置了这个标志之后，当调用进程执行一个新程序时，文件描述符将被关闭</p>
<ul>
<li><strong>FIONCLEX</strong></li>
</ul>
<p>清除执行时关闭标志(File IOctl Not CLose on EXec)。该命令将恢复通常的文件行为，并撤销上述FIOCLEX命令所做的工作。</p>
<ul>
<li><strong>FIOASYNC</strong></li>
</ul>
<p>设置或复位文件异步通知，注意知道Linux 2.2.4 内核都不正确使用这个命令修改O_SYNC标志。因为这两个动作可以通过fcntl完成，所以实际上没人使用这个命令。</p>
<ul>
<li><strong>FIOQSIZE</strong></li>
</ul>
<p>该命令返回文件或者目录的大小。不过当用于设备文件时，会导致ENOTTY错误的返回</p>
<ul>
<li><strong>FIONBIO</strong></li>
</ul>
<p>&ldquo;File IOctl Non-Blocking I/O&rdquo;,文件ioctl非阻塞型I/O。改调用秀阿贵filp-&gt;f_flags中的O_NONBLOCK标志。传递系统调用的第三个参数指明了是设置还是清除该标准。修改该标志的常用方法是由fcntl系统调用使用F_SETFL命令来完成。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/include/uapi/asm-generic/ioctls.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define FIONBIO		0x5421
</span><span class="ln">3</span><span class="cp">#define FIONCLEX	0x5450
</span><span class="ln">4</span><span class="cp">#define FIOCLEX		0x5451
</span><span class="ln">5</span><span class="cp">#define FIOASYNC	0x5452
</span><span class="ln">6</span><span class="cp">#ifndef FIOQSIZE
</span><span class="ln">7</span><span class="cp"># define FIOQSIZE	0x5460
</span><span class="ln">8</span><span class="cp">#endif
</span></code></pre></div><p>另外，还有几个预定义</p>
<p>其实内核cmd有一个格式，使用户cmd不与系统cmd冲突，解决办法就是用<code>_IO</code>、<code>_IOW</code>、<code>_IOR</code>和<code>_IOWR</code>产生cmd。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/include/uapi/linux/fs.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define FIGETBSZ   _IO(0x00,2)	</span><span class="cm">/* get the block size used for bmap */</span><span class="cp">
</span><span class="ln">3</span><span class="cp">#define FIFREEZE	_IOWR(&#39;X&#39;, 119, int)	</span><span class="cm">/* Freeze */</span><span class="cp">
</span><span class="ln">4</span><span class="cp">#define FITHAW		_IOWR(&#39;X&#39;, 120, int)	</span><span class="cm">/* Thaw */</span><span class="cp">
</span><span class="ln">5</span><span class="cp">#define FS_IOC_FIEMAP			_IOWR(&#39;f&#39;, 11, struct fiemap)
</span></code></pre></div></blockquote>
<h4 id="2411inode结构体">2.4.1.1inode结构体</h4>
<p>这里的函数有一个inode结构体。整个结构是比较复杂的数据结构，我们这里只关注<code>i_mode</code>，这个实际上是用于查看是否是可读可写的标志位。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/linux/fs.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
<span class="ln"> 3</span>	<span class="n">umode_t</span>			<span class="n">i_mode</span><span class="p">;</span>
<span class="ln"> 4</span>	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">i_opflags</span><span class="p">;</span>
<span class="ln"> 5</span>	<span class="n">kuid_t</span>			<span class="n">i_uid</span><span class="p">;</span>
<span class="ln"> 6</span>	<span class="n">kgid_t</span>			<span class="n">i_gid</span><span class="p">;</span>
<span class="ln"> 7</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i_flags</span><span class="p">;</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span>	<span class="o">*</span><span class="n">i_op</span><span class="p">;</span>
<span class="ln">10</span>	<span class="k">struct</span> <span class="n">super_block</span>	<span class="o">*</span><span class="n">i_sb</span><span class="p">;</span>
<span class="ln">11</span>	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">i_mapping</span><span class="p">;</span>
<span class="ln">12</span>
<span class="ln">13</span>	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_ino</span><span class="p">;</span>
<span class="ln">14</span>	<span class="k">union</span> <span class="p">{</span>
<span class="ln">15</span>		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_nlink</span><span class="p">;</span>
<span class="ln">16</span>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__i_nlink</span><span class="p">;</span>
<span class="ln">17</span>	<span class="p">};</span>
<span class="ln">18</span>	<span class="n">dev_t</span>			<span class="n">i_rdev</span><span class="p">;</span>
<span class="ln">19</span>	<span class="n">loff_t</span>			<span class="n">i_size</span><span class="p">;</span>
<span class="ln">20</span>	<span class="k">struct</span> <span class="n">timespec64</span>	<span class="n">i_atime</span><span class="p">;</span>
<span class="ln">21</span>	<span class="k">struct</span> <span class="n">timespec64</span>	<span class="n">i_mtime</span><span class="p">;</span>
<span class="ln">22</span>	<span class="k">struct</span> <span class="n">timespec64</span>	<span class="n">i_ctime</span><span class="p">;</span>
<span class="ln">23</span>	<span class="n">spinlock_t</span>		<span class="n">i_lock</span><span class="p">;</span>	<span class="cm">/* i_blocks, i_bytes, maybe i_size */</span>
<span class="ln">24</span>	<span class="kt">unsigned</span> <span class="kt">short</span>          <span class="n">i_bytes</span><span class="p">;</span>
<span class="ln">25</span>	<span class="n">u8</span>			<span class="n">i_blkbits</span><span class="p">;</span>
<span class="ln">26</span>	<span class="n">u8</span>			<span class="n">i_write_hint</span><span class="p">;</span>
<span class="ln">27</span>	<span class="n">blkcnt_t</span>		<span class="n">i_blocks</span><span class="p">;</span>
<span class="ln">28</span>
<span class="ln">29</span>	<span class="cm">/* Misc */</span>
<span class="ln">30</span>	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_state</span><span class="p">;</span>
<span class="ln">31</span>	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">i_rwsem</span><span class="p">;</span>
<span class="ln">32</span>
<span class="ln">33</span>	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dirtied_when</span><span class="p">;</span>	<span class="cm">/* jiffies of first dirtying */</span>
<span class="ln">34</span>	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dirtied_time_when</span><span class="p">;</span>
<span class="ln">35</span>
<span class="ln">36</span>	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">i_hash</span><span class="p">;</span>
<span class="ln">37</span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_io_list</span><span class="p">;</span>	<span class="cm">/* backing dev IO list */</span>
<span class="ln">38</span><span class="cp">#ifdef CONFIG_CGROUP_WRITEBACK
</span><span class="ln">39</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">bdi_writeback</span>	<span class="o">*</span><span class="n">i_wb</span><span class="p">;</span>		<span class="cm">/* the associated cgroup wb */</span>
<span class="ln">40</span>
<span class="ln">41</span>	<span class="cm">/* foreign inode detection, see wbc_detach_inode() */</span>
<span class="ln">42</span>	<span class="kt">int</span>			<span class="n">i_wb_frn_winner</span><span class="p">;</span>
<span class="ln">43</span>	<span class="n">u16</span>			<span class="n">i_wb_frn_avg_time</span><span class="p">;</span>
<span class="ln">44</span>	<span class="n">u16</span>			<span class="n">i_wb_frn_history</span><span class="p">;</span>
<span class="ln">45</span><span class="cp">#endif
</span><span class="ln">46</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_lru</span><span class="p">;</span>		<span class="cm">/* inode LRU list */</span>
<span class="ln">47</span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_sb_list</span><span class="p">;</span>
<span class="ln">48</span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_wb_list</span><span class="p">;</span>	<span class="cm">/* backing dev writeback list */</span>
<span class="ln">49</span>	<span class="k">union</span> <span class="p">{</span>
<span class="ln">50</span>		<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">i_dentry</span><span class="p">;</span>
<span class="ln">51</span>		<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">i_rcu</span><span class="p">;</span>
<span class="ln">52</span>	<span class="p">};</span>
<span class="ln">53</span>	<span class="n">atomic64_t</span>		<span class="n">i_version</span><span class="p">;</span>
<span class="ln">54</span>	<span class="n">atomic64_t</span>		<span class="n">i_sequence</span><span class="p">;</span> <span class="cm">/* see futex */</span>
<span class="ln">55</span>	<span class="n">atomic_t</span>		<span class="n">i_count</span><span class="p">;</span>
<span class="ln">56</span>	<span class="n">atomic_t</span>		<span class="n">i_dio_count</span><span class="p">;</span>
<span class="ln">57</span>	<span class="n">atomic_t</span>		<span class="n">i_writecount</span><span class="p">;</span>
<span class="ln">58</span>	<span class="k">union</span> <span class="p">{</span>
<span class="ln">59</span>		<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">i_fop</span><span class="p">;</span>	<span class="cm">/* former -&gt;i_op-&gt;default_file_ops */</span>
<span class="ln">60</span>		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="ln">61</span>	<span class="p">};</span>
<span class="ln">62</span>	<span class="k">struct</span> <span class="n">file_lock_context</span>	<span class="o">*</span><span class="n">i_flctx</span><span class="p">;</span>
<span class="ln">63</span>	<span class="k">struct</span> <span class="n">address_space</span>	<span class="n">i_data</span><span class="p">;</span>
<span class="ln">64</span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_devices</span><span class="p">;</span>
<span class="ln">65</span>	<span class="k">union</span> <span class="p">{</span>
<span class="ln">66</span>		<span class="k">struct</span> <span class="n">pipe_inode_info</span>	<span class="o">*</span><span class="n">i_pipe</span><span class="p">;</span>
<span class="ln">67</span>		<span class="k">struct</span> <span class="n">cdev</span>		<span class="o">*</span><span class="n">i_cdev</span><span class="p">;</span>
<span class="ln">68</span>		<span class="kt">char</span>			<span class="o">*</span><span class="n">i_link</span><span class="p">;</span>
<span class="ln">69</span>		<span class="kt">unsigned</span>		<span class="n">i_dir_seq</span><span class="p">;</span>
<span class="ln">70</span>	<span class="p">};</span>
<span class="ln">71</span>
<span class="ln">72</span>	<span class="n">__u32</span>			<span class="n">i_generation</span><span class="p">;</span>
<span class="ln">73</span>
<span class="ln">74</span>	<span class="kt">void</span>			<span class="o">*</span><span class="n">i_private</span><span class="p">;</span> <span class="cm">/* fs or device private pointer */</span>
<span class="ln">75</span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div><h4 id="2412-常见的几个文件宏">2.4.1.2 常见的几个文件宏</h4>
<p>关于几个宏定义，可以见下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件宏</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S_ISLNK(st_mode)</td>
<td style="text-align:center">是否是一个连接</td>
</tr>
<tr>
<td style="text-align:center">S_ISREG</td>
<td style="text-align:center">是否是一个常规文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISDIR</td>
<td style="text-align:center">是否是一个目录</td>
</tr>
<tr>
<td style="text-align:center">S_ISCHR</td>
<td style="text-align:center">是否是一个字符设备</td>
</tr>
<tr>
<td style="text-align:center">S_ISBLK</td>
<td style="text-align:center">是否是一个块设备</td>
</tr>
<tr>
<td style="text-align:center">S_ISFIFO</td>
<td style="text-align:center">是否是一个FIFO文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISSOCK</td>
<td style="text-align:center">是否是一个SOCKET文件</td>
</tr>
</tbody>
</table>
<p>下面所示的数据结构定义了stat节点，包含了linux的文件所有的属性</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/uapi/asm-generic/stat.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
<span class="ln"> 3</span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_dev</span><span class="p">;</span>		 <span class="c1">//文件的设备编号
</span><span class="ln"> 4</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_ino</span><span class="p">;</span>		 <span class="c1">//节点
</span><span class="ln"> 5</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">st_mode</span><span class="p">;</span>	<span class="c1">//文件的类型和存取的权限
</span><span class="ln"> 6</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">st_nlink</span><span class="p">;</span>	 <span class="c1">//连到该文件的硬连接数目，刚建立的文件值为1
</span><span class="ln"> 7</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">st_uid</span><span class="p">;</span>		 <span class="c1">//用户ID
</span><span class="ln"> 8</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">st_gid</span><span class="p">;</span>		  <span class="c1">//组ID
</span><span class="ln"> 9</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_rdev</span><span class="p">;</span>	 <span class="c1">//(设备类型)若此文件为设备文件，则为其设备编号
</span><span class="ln">10</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">__pad1</span><span class="p">;</span>
<span class="ln">11</span>	<span class="kt">long</span>		<span class="n">st_size</span><span class="p">;</span>	<span class="c1">//文件字节数(文件大小)
</span><span class="ln">12</span><span class="c1"></span>	<span class="kt">int</span>		<span class="n">st_blksize</span><span class="p">;</span>	 <span class="c1">//块大小(文件系统的I/O 缓冲区大小)
</span><span class="ln">13</span><span class="c1"></span>	<span class="kt">int</span>		<span class="n">__pad2</span><span class="p">;</span>
<span class="ln">14</span>	<span class="kt">long</span>		<span class="n">st_blocks</span><span class="p">;</span>	 <span class="c1">//块数
</span><span class="ln">15</span><span class="c1"></span>	<span class="kt">long</span>		<span class="n">st_atime</span><span class="p">;</span>	 <span class="c1">//最后一次访问时间
</span><span class="ln">16</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_atime_nsec</span><span class="p">;</span>
<span class="ln">17</span>	<span class="kt">long</span>		<span class="n">st_mtime</span><span class="p">;</span>	 <span class="c1">//最后一次修改时间
</span><span class="ln">18</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_mtime_nsec</span><span class="p">;</span>
<span class="ln">19</span>	<span class="kt">long</span>		<span class="n">st_ctime</span><span class="p">;</span>	<span class="c1">//最后一次改变时间(指属性)
</span><span class="ln">20</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">st_ctime_nsec</span><span class="p">;</span>
<span class="ln">21</span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">__unused4</span><span class="p">;</span>
<span class="ln">22</span>	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">__unused5</span><span class="p">;</span>
<span class="ln">23</span><span class="p">};</span>
</code></pre></div><h3 id="242vfs_ioctl">2.4.2vfs_ioctl</h3>
<p>根据上述调用，来到了下面的<code>vfs_ioctl</code>，这里开始就没有<code>fd</code>这个句柄的参数，只需要<code>file</code>结构体指针</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/fs/ioctl.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">long</span> <span class="nf">vfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
<span class="ln"> 3</span>		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">unlocked_ioctl</span><span class="p">)</span>
<span class="ln"> 8</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9</span><span class="n">unlocked_ioctl</span>
<span class="ln">10</span>	<span class="n">error</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">unlocked_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span><span class="c1">//调用unlocked_ioctl()
</span><span class="ln">11</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
<span class="ln">12</span>		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">13</span> <span class="nl">out</span><span class="p">:</span>
<span class="ln">14</span>	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="ln">15</span><span class="p">}</span>	
</code></pre></div><p>这里先关注以下filp-&gt;f_op-&gt;unlocked_ioctl，很明显这里有两个结构体，一个是struct file，另外一个是struct file_operations。对于file结构体，上面2.3.3就有阐述。这里主要是看file_operations结构体。</p>
<h3 id="243struct-file_operations">2.4.3struct file_operations</h3>
<p>这里file_operations结构体中的unlocked_ioctl实际上就是函数指针</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/linux/fs.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">struct</span>  <span class="n">file_operations</span> <span class="p">{</span> 
<span class="ln"> 3</span>	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span> <span class="n">owner</span><span class="p">;</span>
<span class="ln"> 4</span>	<span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span> <span class="n">llseek</span> <span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="p">,</span> <span class="kt">int</span> <span class="p">);</span> 
<span class="ln"> 5</span>	<span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span> <span class="n">read</span> <span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span> <span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln"> 6</span>	<span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span> <span class="n">write</span> <span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span> <span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln"> 7</span>	<span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read_iter</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln"> 8</span>	<span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">write_iter</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln"> 9</span>	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">iterate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dir_context</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln">10</span>	<span class="kt">unsigned</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">)</span> <span class="p">;</span> 
<span class="ln">11</span>	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">);</span> 
<span class="ln">12</span>	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">);</span> 
<span class="ln">13</span>	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span> 
<span class="ln">14</span>	<span class="p">...</span>
<span class="ln">15</span><span class="p">}</span>
</code></pre></div><h3 id="244自定义unlocked_ioctl的真实实现">2.4.4自定义unlocked_ioctl的真实实现</h3>
<p>可以自定义在文件操作集中，那么函数指针实际调用的就是<code>unlocked_ioctl</code>赋值的函数名。下面注册<code>my_ioctl</code>与函数指针<code>unlocked_ioctl</code>关联，直到这里才真正意义上的把ioctl的流程完整的对应起来了。也就是上述2.4.3中的filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg)等于这里的my_ioctl(filp, cmd, arg)</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//文件操作集
</span><span class="ln">2</span><span class="c1"></span><span class="k">struct</span> <span class="n">file_operations</span> <span class="n">misc_fops</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">3</span>    <span class="p">...</span>
<span class="ln">4</span>    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">my_ioctl</span>
<span class="ln">5</span>    <span class="p">...</span>
<span class="ln">6</span><span class="p">};</span>
</code></pre></div><h2 id="25-ioctl-用户与驱动之间的协议">2.5 ioctl 用户与驱动之间的协议</h2>
<p>可以看到下面这个宏定义，这个宏定义包含了协议</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//kernel/include/uapi/asm-generic/ioctl.h
</span><span class="ln">2</span><span class="c1"></span><span class="cp">#define _IOC(dir,type,nr,size) \
</span><span class="ln">3</span><span class="cp">    (((dir)  &lt;&lt; _IOC_DIRSHIFT) | \
</span><span class="ln">4</span><span class="cp">     ((type) &lt;&lt; _IOC_TYPESHIFT) | \
</span><span class="ln">5</span><span class="cp">     ((nr)   &lt;&lt; _IOC_NRSHIFT) | \
</span><span class="ln">6</span><span class="cp">     ((size) &lt;&lt; _IOC_SIZESHIFT))
</span></code></pre></div><p>这个协议就是 ioctl 方法第二个参数<code>cmd</code> 。理论上可以为任意 int 型数据，考虑到4个字节，正好是32位。在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段，如下图2所示</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/ioctl/ioctl_3.png" title="图2 用户与驱动之间的协议图" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/ioctl/ioctl_3.png"  alt="图2 用户与驱动之间的协议图">
  
    </a>
  
   
    <span class="caption">图2 用户与驱动之间的协议图</span>
  
</div>

<table>
<thead>
<tr>
<th>分区</th>
<th style="text-align:center">bit位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个分区(<strong>nr</strong>)</td>
<td style="text-align:center">0-7</td>
<td>命令的<strong>编号</strong>，范围是0-255</td>
</tr>
<tr>
<td>第二个分区(<strong>type</strong>)</td>
<td style="text-align:center">8-15</td>
<td>命令的<strong>幻数</strong></td>
</tr>
<tr>
<td>第三个分区(<strong>size</strong>)</td>
<td style="text-align:center">16-29</td>
<td>表示传递的数据的<strong>大小</strong></td>
</tr>
<tr>
<td>第四个分区(<strong>dir</strong>)</td>
<td style="text-align:center">30-31</td>
<td>代表<strong>读写的方向</strong></td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><strong>nr（number）</strong></p>
<p>命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增；</p>
</li>
<li>
<p><strong>type（device type）</strong></p>
<p>设备类型，占据 8 bit，可以为任意 char 型字符，例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识</p>
</li>
<li>
<p><strong>size</strong></p>
<p>涉及到 ioctl 函数第三个参数 arg ，占据14bit，指定了 arg 的数据类型及长度；</p>
</li>
<li>
<p><strong>dir（direction）</strong></p>
<p>ioctl 命令访问模式（数据传输方向），占据 2 bit</p>
<p>可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，分别指示了四种访问模式：<strong>无数据0x00、读数据0x01、写数据0x11、读写数据0x11</strong></p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/uapi/asm-generic/ioctl.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="cm">/* used to create numbers */</span>
<span class="ln"> 3</span><span class="c1">//定义不带参数的 ioctl 命令
</span><span class="ln"> 4</span><span class="c1"></span><span class="cp">#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)
</span><span class="ln"> 5</span><span class="cp"></span><span class="c1">//定义带写参数的 ioctl 命令（copy_from_user）
</span><span class="ln"> 6</span><span class="c1"></span><span class="cp">#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
</span><span class="ln"> 7</span><span class="cp"></span><span class="c1">//定义带读参数的ioctl命令（copy_to_user）
</span><span class="ln"> 8</span><span class="c1"></span><span class="cp">#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
</span><span class="ln"> 9</span><span class="cp"></span><span class="c1">//定义带读写参数的 ioctl 命令
</span><span class="ln">10</span><span class="c1"></span><span class="cp">#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
</span><span class="ln">11</span><span class="cp"></span>
<span class="ln">12</span><span class="c1">//内核还提供了反向解析 ioctl 命令的宏接口：
</span><span class="ln">13</span><span class="c1"></span><span class="cp">#define _IOC_DIR(nr)        (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)	</span><span class="c1">//方向
</span><span class="ln">14</span><span class="c1"></span><span class="cp">#define _IOC_TYPE(nr)       (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)	</span><span class="c1">//幻数
</span><span class="ln">15</span><span class="c1"></span><span class="cp">#define _IOC_NR(nr)     (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)			</span><span class="c1">//编号
</span><span class="ln">16</span><span class="c1"></span><span class="cp">#define _IOC_SIZE(nr)       (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)	</span><span class="c1">//大小
</span></code></pre></div><h1 id="3举例说明">3举例说明</h1>
<h2 id="31应用层部分">3.1应用层部分</h2>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//external/ioctl_test/ioctl_test.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="ln"> 3</span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="ln"> 4</span><span class="cp">#include</span><span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="ln"> 5</span><span class="cp">#include</span><span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="ln"> 6</span><span class="cp">#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="ln"> 7</span><span class="cp">#include</span><span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
</span><span class="ln"> 8</span><span class="cp"></span>
<span class="ln"> 9</span><span class="cp">#define CMD_TEST_0 _IO(&#39;A&#39;, 0)
</span><span class="ln">10</span><span class="cp">#define CMD_TEST_1 _IOR(&#39;A&#39;, 1, int)
</span><span class="ln">11</span><span class="cp">#define CMD_TEST_2 _IOW(&#39;A&#39;, 2, int)
</span><span class="ln">12</span><span class="cp">#define CMD_TEST_3 _IOWR(&#39;A&#39;, 3, int)
</span><span class="ln">13</span><span class="cp"></span>
<span class="ln">14</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
<span class="ln">15</span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">16</span>    <span class="kt">int</span> <span class="n">revData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">17</span>
<span class="ln">18</span>    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/ioctl_test&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="ln">19</span>    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
<span class="ln">20</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;open failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">21</span>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">22</span>    <span class="p">}</span>
<span class="ln">23</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;open success</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">24</span>
<span class="ln">25</span>    <span class="cm">/*依次调用四个命令*/</span>
<span class="ln">26</span>    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_TEST_0</span><span class="p">);</span>
<span class="ln">27</span>    
<span class="ln">28</span>    <span class="n">revData</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_TEST_1</span><span class="p">);</span>
<span class="ln">29</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;receive 1 data=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">revData</span><span class="p">);</span>
<span class="ln">30</span>
<span class="ln">31</span>    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_TEST_2</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span>
<span class="ln">32</span>
<span class="ln">33</span>    <span class="n">revData</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_TEST_3</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>
<span class="ln">34</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;receive 3 data=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">revData</span><span class="p">);</span>
<span class="ln">35</span>
<span class="ln">36</span>    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="ln">37</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">38</span><span class="p">}</span>
</code></pre></div><h2 id="32驱动层部分">3.2驱动层部分</h2>
<p>在 Linux 内核的include/linux目录下有miscdevice.h文件，要把自己定义的misc device从设备定义在这里。定义一个 MISC 设备(miscdevice 类型)以后我们需要设置 minor、name 和 fops 这三个成员变量。minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux 系统已经预定义了一些 MISC 设备的子设备号。</p>
<p>name 就是此 MISC 设备名字，当此设备注册成功以后就会在/dev 目录下生成一个名为 name的设备文件。fops 就是<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87&amp;spm=1001.2101.3001.7020">字符设备</a>的操作集合，MISC 设备驱动最终是需要使用用户提供的 fops操作集合。</p>
<h3 id="321函数接口">3.2.1函数接口</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//完成misc设备注册。
</span><span class="ln">2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">misc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">miscdevice</span> <span class="o">*</span> <span class="n">misc</span><span class="p">);</span>
<span class="ln">3</span><span class="c1">//完成misc设备注销。
</span><span class="ln">4</span><span class="c1"></span><span class="kt">int</span> <span class="nf">misc_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">miscdevice</span> <span class="o">*</span><span class="n">misc</span><span class="p">);</span>
</code></pre></div><p>驱动部分中的<code>_init</code>，<code>_exit</code>，关键字实际上也是宏定义，可以点击<a href="https://blog.csdn.net/maopig/article/details/7409870">这里</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">  1</span><span class="c1">//kernel/drivers/soc/xxx/sdmmc_ioctl_test.c
</span><span class="ln">  2</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
</span><span class="ln">  3</span><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span><span class="ln">  4</span><span class="cp">#include</span> <span class="cpf">&lt;linux/miscdevice.h&gt;</span><span class="cp">
</span><span class="ln">  5</span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
</span><span class="ln">  6</span><span class="cp">#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
</span><span class="ln">  7</span><span class="cp">#include</span> <span class="cpf">&lt;linux/io.h&gt;</span><span class="cp">
</span><span class="ln">  8</span><span class="cp"></span>
<span class="ln">  9</span><span class="cp">#define CMD_TEST_0 _IO(&#39;A&#39;, 0)       </span><span class="c1">//不需要读写的命令
</span><span class="ln"> 10</span><span class="c1"></span><span class="cp">#define CMD_TEST_1 _IOR(&#39;A&#39;, 1, int) </span><span class="c1">//从内核读取一个int的命令
</span><span class="ln"> 11</span><span class="c1"></span><span class="cp">#define CMD_TEST_2 _IOW(&#39;A&#39;, 2, int) </span><span class="c1">//向内核写入一个int的命令
</span><span class="ln"> 12</span><span class="c1"></span><span class="cp">#define CMD_TEST_3 _IOWR(&#39;A&#39;, 3, int) </span><span class="c1">//读写一个int的命令
</span><span class="ln"> 13</span><span class="c1"></span>
<span class="ln"> 14</span><span class="kt">int</span> <span class="nf">misc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span>
<span class="ln"> 15</span>    <span class="n">printk</span><span class="p">(</span><span class="s">&#34;misc open </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 16</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 17</span><span class="p">}</span>
<span class="ln"> 18</span>
<span class="ln"> 19</span><span class="kt">int</span> <span class="nf">misc_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">b</span><span class="p">){</span>
<span class="ln"> 20</span>    <span class="n">printk</span><span class="p">(</span><span class="s">&#34;misc file release</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 21</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 22</span><span class="p">}</span>
<span class="ln"> 23</span>
<span class="ln"> 24</span><span class="kt">long</span> <span class="nf">my_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
<span class="ln"> 25</span>    <span class="cm">/*将命令按内容分解，打印出来*/</span>
<span class="ln"> 26</span>    <span class="n">printk</span><span class="p">(</span><span class="s">&#34;cmd type=(%c)</span><span class="se">\t</span><span class="s"> nr=(%d)</span><span class="se">\t</span><span class="s"> dir=(%d)</span><span class="se">\t</span><span class="s"> size=(%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 27</span>
<span class="ln"> 28</span>    <span class="cm">/* 检查设备类型 */</span>
<span class="ln"> 29</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IOC_MAGIC</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 30</span>        <span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;[%s] command type [%c] error!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> \
<span class="ln"> 31</span>               <span class="n">__func__</span><span class="p">,</span> <span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 32</span>        <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span> 
<span class="ln"> 33</span>    <span class="p">}</span>
<span class="ln"> 34</span>
<span class="ln"> 35</span>    <span class="cm">/* 检查序数 */</span>
<span class="ln"> 36</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">IOC_MAXNR</span><span class="p">)</span> <span class="p">{</span> 
<span class="ln"> 37</span>        <span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;[%s] command numer [%d] exceeded!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> 
<span class="ln"> 38</span>               <span class="n">__func__</span><span class="p">,</span> <span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 39</span>        <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="ln"> 40</span>    <span class="p">}</span>
<span class="ln"> 41</span>    
<span class="ln"> 42</span>    <span class="cm">/* 检查访问模式 */</span>
<span class="ln"> 43</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_READ</span><span class="p">)</span>
<span class="ln"> 44</span>        <span class="n">ret</span><span class="o">=</span> <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> \
<span class="ln"> 45</span>                        <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 46</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_WRITE</span><span class="p">)</span>
<span class="ln"> 47</span>        <span class="n">ret</span><span class="o">=</span> <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> \
<span class="ln"> 48</span>                        <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 49</span>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln"> 50</span>        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln"> 51</span>
<span class="ln"> 52</span>    <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">){</span>
<span class="ln"> 53</span>        <span class="k">case</span> <span class="nl">CMD_TEST_0</span><span class="p">:</span><span class="c1">//不需要读写的命令
</span><span class="ln"> 54</span><span class="c1"></span>            <span class="n">printk</span><span class="p">(</span><span class="s">&#34;CMD_TEST_0</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 55</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln"> 56</span>        <span class="k">case</span> <span class="nl">CMD_TEST_1</span><span class="p">:</span><span class="c1">//从内核读取一个int的命令
</span><span class="ln"> 57</span><span class="c1"></span>            <span class="n">printk</span><span class="p">(</span><span class="s">&#34;CMD_TEST_1</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 58</span>            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 59</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln"> 60</span>        <span class="k">case</span> <span class="nl">CMD_TEST_2</span><span class="p">:</span><span class="c1">//向内核写入一个int的命令
</span><span class="ln"> 61</span><span class="c1"></span>            <span class="n">printk</span><span class="p">(</span><span class="s">&#34;CMD_TEST_2 date=(%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="ln"> 62</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln"> 63</span>        <span class="k">case</span> <span class="nl">CMD_TEST_3</span><span class="p">:</span><span class="c1">//读写一个int的命令
</span><span class="ln"> 64</span><span class="c1"></span>            <span class="n">printk</span><span class="p">(</span><span class="s">&#34;CMD_TEST_3 date=(%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="ln"> 65</span>            <span class="k">return</span> <span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 66</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln"> 67</span>    <span class="p">}</span>
<span class="ln"> 68</span>
<span class="ln"> 69</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 70</span><span class="p">}</span>
<span class="ln"> 71</span>
<span class="ln"> 72</span><span class="c1">//文件操作集
</span><span class="ln"> 73</span><span class="c1"></span><span class="k">struct</span> <span class="n">file_operations</span> <span class="n">misc_fops</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 74</span>    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="ln"> 75</span>    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">misc_open</span><span class="p">,</span>
<span class="ln"> 76</span>    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">misc_release</span><span class="p">,</span>
<span class="ln"> 77</span>    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">my_ioctl</span>
<span class="ln"> 78</span>    <span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">my_ioctl</span>
<span class="ln"> 79</span><span class="p">};</span>
<span class="ln"> 80</span>
<span class="ln"> 81</span><span class="c1">//ioctl_test，设备节点名,添加了这个语句可以在设备中ls找到这个设备节点，并且是c开头的
</span><span class="ln"> 82</span><span class="c1"></span><span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">misc_dev</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 83</span>    <span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
<span class="ln"> 84</span>    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;ioctl_test&#34;</span><span class="p">,</span>   
<span class="ln"> 85</span>    <span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">misc_fops</span>
<span class="ln"> 86</span><span class="p">};</span>
<span class="ln"> 87</span>
<span class="ln"> 88</span><span class="c1">//这里的__exit,这是一个宏定义,同下面的__init类似
</span><span class="ln"> 89</span><span class="c1"></span><span class="k">static</span> <span class="n">__exit</span> <span class="kt">int</span> <span class="nf">ioctl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="ln"> 90</span>    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 91</span>
<span class="ln"> 92</span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">misc_dev</span><span class="p">);</span>  <span class="c1">//注册杂项设备
</span><span class="ln"> 93</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
<span class="ln"> 94</span>        <span class="n">printk</span><span class="p">(</span><span class="s">&#34;misc regist failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 95</span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 96</span>    <span class="p">}</span>
<span class="ln"> 97</span>
<span class="ln"> 98</span>    <span class="n">printk</span><span class="p">(</span><span class="s">&#34;misc regist succeed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 99</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">100</span><span class="p">}</span>
<span class="ln">101</span>
<span class="ln">102</span><span class="c1">//这里的__init，这是一个宏定义
</span><span class="ln">103</span><span class="c1">//最常用的地方是驱动模块初始化函数的定义处，其目的是将驱动模块的初始化函数放入名叫.init.text的输入段
</span><span class="ln">104</span><span class="c1"></span><span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">ioctl_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="ln">105</span>    <span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">misc_dev</span><span class="p">);</span>
<span class="ln">106</span><span class="p">}</span>
<span class="ln">107</span>
<span class="ln">108</span><span class="c1">//下面这两个宏，可以展开
</span><span class="ln">109</span><span class="c1"></span><span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&#34;Dual BSD/GPL&#34;</span><span class="p">);</span>
<span class="ln">110</span><span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&#34;yangyang48&#34;</span><span class="p">);</span>
<span class="ln">111</span>
<span class="ln">112</span><span class="c1">//这里可以改成module_init
</span><span class="ln">113</span><span class="c1"></span><span class="n">device_initcall_sync</span><span class="p">(</span><span class="n">ioctl_init</span><span class="p">);</span> 
<span class="ln">114</span><span class="n">module_exit</span><span class="p">(</span><span class="n">ioctl_exit</span><span class="p">);</span>  
</code></pre></div><blockquote>
<p>MODULE_AUTHOR和MODULE_LICENSE宏定义</p>
<p>这部分其实就是许多宏定义的嵌套，具体可以点击<a href="https://blog.csdn.net/qq_36412526/article/details/82885631">这里</a>，可以详细的宏定义的展开说明</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//kernel/include/linux/module.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
</span><span class="ln"> 3</span><span class="cp">#define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
</span><span class="ln"> 4</span><span class="cp"></span>
<span class="ln"> 5</span><span class="c1">// 连接形参的宏
</span><span class="ln"> 6</span><span class="c1"></span><span class="cp">#define ___module_cat(a,b) __mod_ ## a ## b 
</span><span class="ln"> 7</span><span class="cp">#define __module_cat(a,b) ___module_cat(a,b)
</span><span class="ln"> 8</span><span class="cp"></span>
<span class="ln"> 9</span><span class="cp">#ifdef MODULE
</span><span class="ln">10</span><span class="cp">#define __MODULE_INFO(tag, name, info)					  \
</span><span class="ln">11</span><span class="cp">static const char __module_cat(name,__LINE__)[]				  \
</span><span class="ln">12</span><span class="cp">  __used __attribute__((section(&#34;.modinfo&#34;), unused, aligned(1)))	  \
</span><span class="ln">13</span><span class="cp">  = __stringify(tag) &#34;=&#34; info
</span><span class="ln">14</span><span class="cp">#else  </span><span class="cm">/* !MODULE */</span><span class="cp">
</span><span class="ln">15</span><span class="cp"></span><span class="cm">/* This struct is here for syntactic coherency, it is not used */</span>
<span class="ln">16</span><span class="cp">#define __MODULE_INFO(tag, name, info)					  \
</span><span class="ln">17</span><span class="cp">  struct __module_cat(name,__LINE__) {}
</span><span class="ln">18</span><span class="cp">#endif
</span></code></pre></div><p>MODULE_AUTHOR这部分其实可以直接展开</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__mod_authorXX</span><span class="p">[]</span>  \
<span class="ln">2</span> <span class="n">__used</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;.modinfo&#34;</span><span class="p">),</span><span class="n">unused</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>  \
<span class="ln">3</span> <span class="o">=</span> <span class="s">&#34;author = yangyang48&#34;</span>
</code></pre></div><p>同理，MODULE_LICENSE也可以展开</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__mod_licenseXX</span><span class="p">[]</span>  \
<span class="ln">2</span> <span class="n">__used</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;.modinfo&#34;</span><span class="p">),</span><span class="n">unused</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>  \
<span class="ln">3</span> <span class="o">=</span> <span class="s">&#34;license= Dual BSD/GPL&#34;</span>
</code></pre></div></blockquote>
<h3 id="322驱动的校验部分">3.2.2驱动的校验部分</h3>
<p>上面有一段内容是检验的部分，主要用于对用户自定义的协议进行校验。</p>
<ul>
<li>如果是cmd中的dir为读取模式，那么是用户空间向内核空间读取数据，那么需要检查用户空间的可写空间地址。</li>
<li>如果是cmd中的dir为可写模式，那么是用户空间向内核空间写数据，那么需要检查用户空间的可写空间地址。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="cm">/* 检查设备类型 */</span>
<span class="ln"> 2</span><span class="c1">//这里定义的type是&#39;A&#39;
</span><span class="ln"> 3</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IOC_MAGIC</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4</span>    <span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;[%s] command type [%c] error!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> \
<span class="ln"> 5</span>           <span class="n">__func__</span><span class="p">,</span> <span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln"> 6</span>    <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span> 
<span class="ln"> 7</span><span class="p">}</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span><span class="cm">/* 检查序数 */</span>
<span class="ln">10</span><span class="c1">//这里定义的序数为4
</span><span class="ln">11</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">IOC_MAXNR</span><span class="p">)</span> <span class="p">{</span> 
<span class="ln">12</span>    <span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;[%s] command numer [%d] exceeded!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> 
<span class="ln">13</span>           <span class="n">__func__</span><span class="p">,</span> <span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln">14</span>    <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="ln">15</span><span class="p">}</span>    
<span class="ln">16</span>
<span class="ln">17</span><span class="cm">/* 检查访问模式 */</span>
<span class="ln">18</span><span class="k">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_READ</span><span class="p">)</span>
<span class="ln">19</span>    <span class="n">ret</span><span class="o">=</span> <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> \
<span class="ln">20</span>                    <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln">21</span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_WRITE</span><span class="p">)</span>
<span class="ln">22</span>    <span class="n">ret</span><span class="o">=</span> <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> \
<span class="ln">23</span>                    <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="ln">24</span><span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">25</span>    <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</code></pre></div><blockquote>
<p>补充</p>
<p>这里的access_ok函数，主要是防止内核被外部攻击</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//返回值：布尔值，1表示成功，0表示失败
</span><span class="ln">2</span><span class="c1">//type:检查用户空间地址的权限；VERIFY_READ或者VERIFY_WRITE；
</span><span class="ln">3</span><span class="c1">//&lt;1&gt;VERIFY_READ：驱动是否可以读取用户空间的指定地址；
</span><span class="ln">4</span><span class="c1">//&lt;2&gt;VERIFY_WRITE：驱动是否可以读取用户空间的指定地址；
</span><span class="ln">5</span><span class="c1">//&lt;3&gt;VERIFY_WRITE：驱动在指定用户空间地址既要读取也要写入，也是填这个；
</span><span class="ln">6</span><span class="c1">//addr：用户空间地址；
</span><span class="ln">7</span><span class="c1">//size:要操作的字节数；例如驱动要从指定用户空间地址读取一个int型整数，则size就是sizeof(int)；
</span><span class="ln">8</span><span class="c1"></span><span class="kt">int</span> <span class="nf">access_ok</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></blockquote>
<h3 id="323调用流程总结">3.2.3调用流程总结</h3>
<p>最终得到的调用流程如下所示，通过用户态调用的ioctl函数设备节点/dev/ioctl_test最终在内核态的my_ioctl实现这个流程。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/ioctl/ioctl_2.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/ioctl/ioctl_2.png" >
  
    </a>
  
  
</div>

<h2 id="33编译">3.3编译</h2>
<p>kernel在驱动层的编译，需要依赖于Kconfig和Makefile文件；在应用层的编译，需要依赖于Android.mk。</p>
<h3 id="331驱动层的编译">3.3.1驱动层的编译</h3>
<ul>
<li>Kconfig
每个源码目录下提供选项</li>
<li>.config
源码顶层目录下保存选择结果</li>
<li>Makefile
每个源码目录下根据.config中的内容来告知编译系统如何编译</li>
</ul>
<p>从这里可以看到，这里也是有一定的语法规则。其中Kconfig用来配置内核，它就是各种配置界面的源文件，内核的配置工具读取各个Kconfig文件，生成配置界面供开发人员配置内核，最后<strong>生成配置文件.config</strong>。</p>
<p><code>config</code>是关键字，表示一个配置选项的开始；紧跟着的<code>IOCTL_TEST</code>是配置选项的名称，省略了前缀<code>CONFIG_</code>
bool表示变量类型，即<code>CONFIG_IOCTL_TEST </code>的类型。</p>
<p><strong>字符串“This is IOCTL_TEST”是提示信息</strong>，在配置界面中上下移动光标选中它时，就可以通过按空格或回车键来设置<code>CONFIG_IOCTL_TEST </code>的值</p>
<p>default代表tristate变量的值，一共有三个值y、n和m。如果是n代表所需要的文件不需要被编译进去，这里笔者需要编译进入所有使得，<code>CONFIG_IOCTL_TEST </code>的值为y。</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>config IOCTL_TEST
<span class="ln">2</span>    bool &#34;This is IOCTL_TEST&#34;
<span class="ln">3</span>    default y
<span class="ln">4</span>    help
<span class="ln">5</span>      IOCTL TEST support permissions for users and groups beyond the owner/group/world scheme.
<span class="ln">6</span>      If you don&#39;t know what Access Control Lists are, say N.
</code></pre></div><p>然后在Makefile文件中添加这个需要编译的二进制文件</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="ln">1</span><span class="nv">obj-y</span> <span class="o">+=</span> sdmmc_ioctl_test.o
<span class="ln">2</span><span class="err">//可以写成上述的样子</span>
<span class="ln">3</span><span class="nv">obj-$(CONFIG_IOCTL_TEST)</span> <span class="o">+=</span> sdmmc_ioctl_test.o
</code></pre></div><h3 id="332应用层编译">3.3.2应用层编译</h3>
<p>这个比较简单，就是单纯的Android.mk文件即可</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="ln">1</span><span class="nv">LOCAL_PATH</span> <span class="o">:=</span> <span class="k">$(</span>call my-dir<span class="k">)</span>
<span class="ln">2</span><span class="err">include</span> <span class="k">$(</span><span class="nv">CLEAR_VARS</span><span class="k">)</span>
<span class="ln">3</span><span class="nv">LOCAL_MODULE</span> <span class="o">:=</span> ioctl_test
<span class="ln">4</span><span class="nv">LOCAL_SRC_FILES</span> <span class="o">+=</span> ioctl_test.c
<span class="ln">5</span><span class="nv">LOCAL_C_INCLUDE</span> <span class="o">+=</span> <span class="k">$(</span>LOCAL_PATH<span class="k">)</span>/
<span class="ln">6</span><span class="nv">LOCAL_C_FLAG</span> <span class="o">:=</span> -Wreturn-local-addr -Wwriting_strings -fpermissive -fexceptions -Wall -Wno-unused-variable -lgcc_s -std<span class="o">=</span>c99
<span class="ln">7</span><span class="c">#编译生成动态文件so
</span><span class="ln">8</span><span class="c"></span><span class="err">include</span> <span class="k">$(</span><span class="nv">BUILD_SHARE_LIBRARY</span><span class="k">)</span>
<span class="ln">9</span><span class="err">include</span> <span class="k">$(</span><span class="nv">call</span> <span class="nv">all_makefiles_under</span>, <span class="k">$(</span><span class="nv">LOCAL_PATH</span><span class="k">))</span>
</code></pre></div><h1 id="4总结">4总结</h1>
<p>ioctl 是一种面向硬件驱动，是内核比较早的一种用户态内核态的交互方式，侧重于文件系统，方便添加对硬件驱动的处理。</p>
<p>ioctl机制可以在驱动中扩展特定的ioctl消息，用于将一些状态从内核反应到用户态。ioctl有很好的数据同步保护机制，不用担心内核和用户层的数据访问冲突，<strong>但是ioctl不适合传输大量的数据</strong>。</p>
<p>本文通过介绍ioctl函数的流程，涉及到<strong>软中断</strong>、<strong>系统调用表</strong>、<strong>file结构指针</strong>、<strong>用户与驱动之间的协议</strong>，通过一个demo把整个流程贯穿一遍，更好的熟悉了解到整个ioctl的通信流程。</p>
<h1 id="两个可以参考的源码网站">两个可以参考的源码网站</h1>
<p><a href="http://aospxref.com/android-11.0.0_r21/">aospxref.com</a></p>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?h=v5.19-rc7">kernel.org</a></p>
<h1 id="5下载">5下载</h1>
<p>本文源码下载，点击<a href="https://github.com/YangYang48/project/tree/master/ioctl">这里</a></p>
<h1 id="参考">参考</h1>
<p><a href="https://mp.weixin.qq.com/s/8zoa7Ywftm4TmLdf8PAPFg">[1]酷派技术团队, Linux用户态与内核态通信方式介绍及选型参考, 2022.</a></p>
<p><a href="https://www.cnblogs.com/TaXueWuYun/p/15315594.html">[2] WuYunTaXue, ioctl使用方法, 2021.</a></p>
<p><a href="https://www.cnblogs.com/pingandezhufu/p/4392642.html">[3] pingandezhufu, Linux内核system_call中断处理过程, 2015.</a></p>
<p><a href="https://www.cnblogs.com/TaXueWuYun/p/15315594.html">[4] WuYunTaXue, ioctl使用方法, 2022.</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1944012">[5] 鸿鹄实验室, 浅析syscall, 2021.</a></p>
<p><a href="https://blog.csdn.net/weixin_43798887/article/details/118930476">[6] 彼 方, Linux系统调用SYSCALL_DEFINE详解, 2021.</a></p>
<p><a href="https://blog.csdn.net/maopig/article/details/7409870">[7] maopig, 内核中_init，_exit中的作用, 2012.</a></p>
<p><a href="https://unbroken.blog.csdn.net/article/details/84789220">[8] Android系统攻城狮, GFP_KERNEL的作用, 2018.</a></p>
<p><a href="https://blog.csdn.net/dongxianfei/article/details/118256267">[9] 雪舞飞影, ioctl函数详解（Linux内核 ）, 2021.</a></p>
<p><a href="https://blog.csdn.net/weixin_38815998/article/details/103510385">[10] ora___, ioctl系统调用过程(深入Linux(ARM)内核源码), 2019.</a></p>
<p><a href="https://xuesong.blog.csdn.net/article/details/81489268">[11] 内核笔记, RK3399平台开发系列讲解（内核入门篇）1.8、IOCTL的用法详解, 2022.</a></p>
<p><a href="https://blog.csdn.net/monkea123/article/details/109137398">[12] monkea123, 杂项设备（misc device）, 2020.</a></p>
<p><a href="https://www.cnblogs.com/hazir/p/array_initialization.html">[13] 菜鸟程序员的成长历程,Linux Kernel代码艺术——数组初始化 , 2013.</a></p>
<p><a href="https://blog.csdn.net/wojiaowoen/article/details/107938455">[14] Felix_8_, Kconfig文件的用途及解析, 2020.</a></p>
<p><a href="https://blog.csdn.net/weixin_42817735/article/details/122982569">[15] 无棱, Kconfig, 2022.</a></p>
<p><a href="https://blog.csdn.net/qq_36412526/article/details/82885631">[16] qq_36412526, MODULE_AUTHOR宏(一), 2018.</a></p>
<p><a href="https://www.jianshu.com/p/2f092e81cbc1?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">[17] c枫_撸码的日子, [读书笔记]高级字符驱动程序（第六章）, 2018.</a></p>
<p><a href="https://blog.csdn.net/bytxl/article/details/8215116">[18] bytxl, S_ISDIR S_ISREG等常见的几个宏, 2012.</a></p>
<p><a href="https://blog.csdn.net/weixin_42817735/article/details/122982569">[19] 正在起飞的蜗牛, access_ok()函数介绍, 2022.</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/94020714">[20] 宋宝华, 为什么内核访问用户数据之前，要做access_ok?, 2019.</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/kernel/">kernel</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/">软中断</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/">系统调用表</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E7%94%A8%E6%88%B7%E4%B8%8E%E9%A9%B1%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E8%AE%AE/">用户与驱动之间的协议</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E9%A9%B1%E5%8A%A8/">驱动</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/android/">Android</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E6%BA%90%E7%A0%81/">源码</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%A1%E7%A8%8B/" data-tooltip="操作系统学习笔记 10信号量&amp;管程">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" data-tooltip="操作系统学习笔记 9同步&amp;互斥">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
		
		<div class="post-comment main-content-wrap">
		
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'mwl8M1aQzLnRE6JIpIY3sgE5-9Nh9j0Va',
        appKey: 'mPGr6GMC0BuzAKkxinnd0IAr',
        notify:  true , 
        verify:  false , 
        avatar:'retro', 
        placeholder: '欢迎各位宝宝留言~',
        visitor:  true 
    });
  </script>

		</div>
        <footer id="footer" class="main-content-wrap">
  
  
  
  <span class="copyrights">
    &copy; 2024 Yang Ju. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%A1%E7%A8%8B/" data-tooltip="操作系统学习笔记 10信号量&amp;管程">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2022/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" data-tooltip="操作系统学习笔记 9同步&amp;互斥">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fyangyang48.github.io%2F2022%2F07%2Fioctl%25E9%2580%259A%25E4%25BF%25A1%25E6%2596%25B9%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259D%25E5%2587%25BA%25E8%258C%2585%25E5%25BA%2590%2F">
          <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fyangyang48.github.io%2F2022%2F07%2Fioctl%25E9%2580%259A%25E4%25BF%25A1%25E6%2596%25B9%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259D%25E5%2587%25BA%25E8%258C%2585%25E5%25BA%2590%2F">
          <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2Fyangyang48.github.io%2F2022%2F07%2Fioctl%25E9%2580%259A%25E4%25BF%25A1%25E6%2596%25B9%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259D%25E5%2587%25BA%25E8%258C%2585%25E5%25BA%2590%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">Yang Ju</h4>
    
      <div id="about-card-bio">Nanjing University of Science and Technology</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Development Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        NanJing,China
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://yangyang48.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://yangyang48.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


  
    <script src="https://yangyang48.github.io/js/copy-to-clipboard.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/yangyang48.github.io\/2022\/07\/ioctl%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90\/';
          
            this.page.identifier = '\/2022\/07\/ioctl%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

