<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.85.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Yang Ju">
<meta name="keywords" content="">
<meta name="description" content="本文以最通俗易懂的方式结合源码分析Linux的TCP/IP协议栈发送过程。">


<meta property="og:description" content="本文以最通俗易懂的方式结合源码分析Linux的TCP/IP协议栈发送过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux的TCP/IP协议栈发送过程">
<meta name="twitter:title" content="Linux的TCP/IP协议栈发送过程">
<meta property="og:url" content="https://yangyang48.github.io/2023/02/linux%E7%9A%84tcp/ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/">
<meta property="twitter:url" content="https://yangyang48.github.io/2023/02/linux%E7%9A%84tcp/ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/">
<meta property="og:site_name" content="欢迎来到我的博客~">
<meta property="og:description" content="本文以最通俗易懂的方式结合源码分析Linux的TCP/IP协议栈发送过程。">
<meta name="twitter:description" content="本文以最通俗易懂的方式结合源码分析Linux的TCP/IP协议栈发送过程。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2023-02-05T00:00:00">
  
  
    <meta property="article:modified_time" content="2023-02-05T00:00:00">
  
  
  
    
      <meta property="article:section" content="socket">
    
      <meta property="article:section" content="2023">
    
      <meta property="article:section" content="February">
    
  
  
    
      <meta property="article:tag" content="Linux">
    
      <meta property="article:tag" content="TCP/IP协议栈">
    
      <meta property="article:tag" content="发送">
    
      <meta property="article:tag" content="源码">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://yangyang48.github.io/tcpip/send/send_thumb.jpg">
  <meta property="twitter:image" content="https://yangyang48.github.io/tcpip/send/send_thumb.jpg">


  <meta property="og:image" content="https://yangyang48.github.io/tcpip/send/send_cover.png">
  <meta property="twitter:image" content="https://yangyang48.github.io/tcpip/send/send_cover.png">




  <meta property="og:image" content="https://yangyang48.github.io/thumb/20210711204627625.jpg">
  <meta property="twitter:image" content="https://yangyang48.github.io/thumb/20210711204627625.jpg">


    <title>Linux的TCP/IP协议栈发送过程</title>

    <link rel="icon" href="https://yangyang48.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://yangyang48.github.io/2023/02/linux%E7%9A%84tcp/ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://yangyang48.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://yangyang48.github.io/css/copy-to-clipboard.css">
      
    

    
      
    
    

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://yangyang48.github.io/">欢迎来到我的博客~</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://yangyang48.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://yangyang48.github.io/#about">
          <img class="sidebar-profile-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Yang Ju</h4>
        
          <h5 class="sidebar-profile-bio">Nanjing University of Science and Technology</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yangyang48.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/YangYang48" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://blog.csdn.net/yangju147532896" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-chain"></i>
      
      <span class="sidebar-button-desc">CSDN</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              "
       style="background-image:url('/tcpip/send/send_cover.png')"
       data-behavior="4">
    
  </div>


      <div id="main" data-behavior="4"
        class="hasCover
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      Linux的TCP/IP协议栈发送过程
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2023-02-05T00:00:00Z">
        
  二月 5, 2023

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://yangyang48.github.io/categories/socket">socket</a>, 
    
      <a class="category-link" href="https://yangyang48.github.io/categories/2023">2023</a>, 
    
      <a class="category-link" href="https://yangyang48.github.io/categories/february">February</a>
    
  

  </div>

</div>
          
		  
		  <h5 id="wc" style="font-size: 1rem;text-align: center;">2600 Words|Read in about 13 Min|本文总阅读量<span id="busuanzi_value_page_pv"></span>次</h5>
		  
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>本文以最通俗易懂的方式结合源码分析Linux的TCP/IP协议栈发送过程。</p>
<p><!-- raw HTML omitted -->（本文主要是张彦飞的梳理的发送框架，适当做了梳理，原文可以点击<a href="https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ">这里</a>）。<!-- raw HTML omitted --></p>
<p>关于TCP/IP的协议栈流程基本上在计算机网络中就已经熟悉了，如下所示</p>
<p>但是对于其中的源码跟读就比较陌生，甚至找到了也被复杂庞大的架构劝退了，本文就尝试以最简单的方式去梳理这个<strong>TCP的发送</strong>流程，大喊一声：老乡，别走~</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_31.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_31.png" >
  
    </a>
  
  
</div>

<p>如下代码是一个服务端简单的实例</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="ln"> 2</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3</span> <span class="n">bind</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">...);</span>
<span class="ln"> 4</span> <span class="n">listen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">...);</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span> <span class="n">cfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">...);</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span> <span class="c1">// 接收用户请求
</span><span class="ln"> 9</span><span class="c1"></span> <span class="n">read</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="p">...);</span>
<span class="ln">10</span>
<span class="ln">11</span> <span class="c1">// 用户请求处理
</span><span class="ln">12</span><span class="c1"></span> <span class="n">dosometing</span><span class="p">();</span> 
<span class="ln">13</span>
<span class="ln">14</span> <span class="c1">// 给用户返回结果
</span><span class="ln">15</span><span class="c1"></span> <span class="n">send</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">16</span><span class="p">}</span>
</code></pre></div><p>调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/?h=v6.1.9">6.1.9</a>为例，网卡驱动采用Intel的igb网卡举例。关于socket的使用方式，可以点击<a href="https://yangyang48.github.io/2023/01/socket%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0linux%E9%99%84android%E6%BA%90%E7%A0%81/">这里</a>查看。</p>
<h1 id="1linux-网络发送过程总览">1Linux 网络发送过程总览</h1>
<p>我觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。</p>
<p>我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_1.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_1.png" >
  
    </a>
  
  
</div>

<p>在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。</p>
<p>因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_2.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_2.png" >
  
    </a>
  
  
</div>



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_3.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_3.png" >
  
    </a>
  
  
</div>



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_4.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_4.png" >
  
    </a>
  
  
</div>



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_5.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_5.png" >
  
    </a>
  
  
</div>



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_6.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_6.png" >
  
    </a>
  
  
</div>

<p>在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。</p>
<p>因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_7.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_7.png" >
  
    </a>
  
  
</div>



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_8.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_8.png" >
  
    </a>
  
  
</div>

<p>注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）</p>
<p><strong>意不意外，惊不惊喜？？？</strong></p>
<p>所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。</p>
<blockquote>
<p>问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？</p>
<p>传输完成最终会触发 NET_RX，而不是 NET_TX。所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。</p>
</blockquote>
<p>好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！</p>
<h1 id="2网卡启动准备">2网卡启动准备</h1>
<p>现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_9.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_9.png" >
  
    </a>
  
  
</div>

<p>网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。</p>
<p>在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">__igb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">resuming</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="c1">//分配传输描述符数组
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="c1">//分配接收描述符数组
</span><span class="ln">10</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">igb_setup_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="c1">//开启全部队列
</span><span class="ln">13</span><span class="c1"></span>    <span class="n">netif_tx_start_all_queues</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="ln">14</span><span class="p">}</span>
</code></pre></div><p>在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_setup_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="c1">//有几个队列就构造几个 RingBuffer
</span><span class="ln">5</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6</span>        <span class="n">igb_setup_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="ln">7</span>    <span class="p">}</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><p>真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">igb_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//1.申请 igb_tx_buffer 数组内存
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_tx_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="ln"> 6</span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="c1">//2.申请 e1000_adv_tx_desc DMA 数组内存
</span><span class="ln"> 9</span><span class="c1"></span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_adv_tx_desc</span><span class="p">);</span>
<span class="ln">10</span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
<span class="ln">11</span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
<span class="ln">12</span>                                       <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="ln">13</span>
<span class="ln">14</span>    <span class="c1">//3.初始化队列成员
</span><span class="ln">15</span><span class="c1"></span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">16</span>    <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">17</span><span class="p">}</span>
</code></pre></div><p>从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。</p>
<p>1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。
2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。</p>
<p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_10.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_10.png" >
  
    </a>
  
  
</div>

<p>最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。</p>
<h1 id="3accept-创建新-socket">3accept 创建新 socket</h1>
<p>在发送数据之前，我们往往还需要一个已经建立好连接的 socket。</p>
<p>我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。</p>
<p>假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_11.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_11.png" >
  
    </a>
  
  
</div>

<p>其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_12.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_12.png" >
  
    </a>
  
  
</div>
</p>
<p>为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了。今天我们还是把重点放到数据发送过程上。</p>
<h1 id="4发送数据真正开始">4发送数据真正开始</h1>
<h3 id="41-send-系统调用实现">4.1 send 系统调用实现</h3>
<p>send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，</p>
<ul>
<li>第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。</li>
<li>第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去.</li>
</ul>
<p>剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_13.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_13.png" >
  
    </a>
  
  
</div>

<p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/socket.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">send</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
<span class="ln"> 3</span>                <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="k">return</span> <span class="n">sys_sendto</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 6</span><span class="p">}</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span><span class="n">SYSCALL_DEFINE6</span><span class="p">(......)</span>
<span class="ln"> 9</span><span class="p">{</span>
<span class="ln">10</span>    <span class="c1">//1.根据 fd 查找到 socket
</span><span class="ln">11</span><span class="c1"></span>    <span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
<span class="ln">12</span>
<span class="ln">13</span>    <span class="c1">//2.构造 msghdr
</span><span class="ln">14</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
<span class="ln">15</span>    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
<span class="ln">16</span>
<span class="ln">17</span>    <span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
<span class="ln">18</span>    <span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="ln">19</span>    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">20</span>
<span class="ln">21</span>    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
<span class="ln">22</span>    <span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">23</span>    <span class="p">......</span>
<span class="ln">24</span>
<span class="ln">25</span>    <span class="c1">//3.发送数据
</span><span class="ln">26</span><span class="c1"></span>    <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="ln">27</span><span class="p">}</span>
</code></pre></div><p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。</p>
<p>在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。</p>
<p>接着调用了 sock_sendmsg =&gt; __sock_sendmsg ==&gt;  __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//net/socket.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sock_sendmsg_nosec</span><span class="p">(...)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="p">......</span>
<span class="ln">5</span>    <span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div><p>通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock-&gt;ops-&gt;sendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。</p>
<h1 id="42传输层处理">4.2传输层处理</h1>
<h3 id="421传输层拷贝">4.2.1传输层拷贝</h3>
<p>在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。</p>
<p>在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图：</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_14.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_14.png" >
  
    </a>
  
  
</div>

<p>我们来看 inet_sendmsg 函数的源码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//net/ipv4/af_inet.c
</span><span class="ln">2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">inet_sendmsg</span><span class="p">(......)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="p">......</span>
<span class="ln">5</span>    <span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">sendmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div><p>在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk-&gt;sk_prot-&gt;sendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。</p>
<p>tcp_sendmsg 这个函数比较长，我们分多次来看它。先看这一段</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/tcp.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">tcp_sendmsg</span><span class="p">(...)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="k">while</span><span class="p">(...){</span>
<span class="ln"> 5</span>        <span class="k">while</span><span class="p">(...){</span>
<span class="ln"> 6</span>            <span class="c1">//获取发送队列
</span><span class="ln"> 7</span><span class="c1"></span>            <span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>            <span class="c1">//申请skb 并拷贝
</span><span class="ln">10</span><span class="c1"></span>            <span class="p">......</span>
<span class="ln">11</span>        <span class="p">}</span>
<span class="ln">12</span>    <span class="p">}</span>
<span class="ln">13</span><span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/net/tcp.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_write_queue_tail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="k">return</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="ln">5</span><span class="p">}</span>
</code></pre></div><p>理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_15.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_15.png" >
  
    </a>
  
  
</div>

<p>我们再接着看 tcp_sendmsg 的其它部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/tcp.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">tcp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<span class="ln"> 3</span>                <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="c1">//获取用户传递过来的数据和标志
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="n">iov</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">;</span> <span class="c1">//用户数据地址
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="n">iovlen</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">;</span> <span class="c1">//数据块数为1
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="n">flags</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">;</span> <span class="c1">//各种标志
</span><span class="ln"> 9</span><span class="c1"></span>
<span class="ln">10</span>    <span class="c1">//遍历用户层的数据块
</span><span class="ln">11</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">iovlen</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">12</span>
<span class="ln">13</span>        <span class="c1">//待发送数据块的地址
</span><span class="ln">14</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
<span class="ln">15</span>
<span class="ln">16</span>        <span class="k">while</span> <span class="p">(</span><span class="n">seglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">17</span>
<span class="ln">18</span>            <span class="c1">//需要申请新的 skb
</span><span class="ln">19</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">20</span>
<span class="ln">21</span>                <span class="c1">//申请 skb，并添加到发送队列的尾部
</span><span class="ln">22</span><span class="c1"></span>                <span class="n">skb</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
<span class="ln">23</span>                                          <span class="n">select_size</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sg</span><span class="p">),</span>
<span class="ln">24</span>                                          <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
<span class="ln">25</span>
<span class="ln">26</span>                <span class="c1">//把 skb 挂到socket的发送队列上
</span><span class="ln">27</span><span class="c1"></span>                <span class="n">skb_entail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">28</span>            <span class="p">}</span>
<span class="ln">29</span>
<span class="ln">30</span>            <span class="c1">// skb 中有足够的空间
</span><span class="ln">31</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">skb_availroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">32</span>                <span class="c1">//拷贝用户空间的数据到内核空间，同时计算校验和
</span><span class="ln">33</span><span class="c1"></span>                <span class="c1">//from是用户空间的数据地址 
</span><span class="ln">34</span><span class="c1"></span>                <span class="n">skb_add_data_nocache</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
<span class="ln">35</span>            <span class="p">}</span> 
<span class="ln">36</span>            <span class="p">......</span>
<span class="ln">37</span>        <span class="p">}</span>
<span class="ln">38</span>    <span class="p">}</span>
<span class="ln">39</span><span class="p">}</span>
</code></pre></div><p>这个函数比较长，不过其实逻辑并不复杂。其中 msg-&gt;msg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。<strong>这就会涉及到一次或者几次内存拷贝的开销</strong>。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_16.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_16.png" >
  
    </a>
  
  
</div>

<p>至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/tcp.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">tcp_sendmsg</span><span class="p">(...)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="k">while</span><span class="p">(...){</span>
<span class="ln"> 5</span>        <span class="k">while</span><span class="p">(...){</span>
<span class="ln"> 6</span>            <span class="c1">//申请内核内存并进行拷贝
</span><span class="ln"> 7</span><span class="c1"></span>
<span class="ln"> 8</span>            <span class="c1">//发送判断
</span><span class="ln"> 9</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">forced_push</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">10</span>                <span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">11</span>                <span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">);</span>
<span class="ln">12</span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
<span class="ln">13</span>                <span class="n">tcp_push_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>  
<span class="ln">14</span>        <span class="p">}</span>
<span class="ln">15</span>        <span class="k">continue</span><span class="p">;</span>
<span class="ln">16</span>    <span class="p">}</span>
<span class="ln">17</span><span class="p">}</span>
</code></pre></div><p>只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。</p>
<p>条件都不满足的话，<strong>这次的用户要发送的数据只是拷贝到内核就算完事了！</strong></p>
<h3 id="422传输层发送">4.2.2传输层发送</h3>
<p>假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。</p>
<p>所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_17.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_17.png" >
  
    </a>
  
  
</div>

<p>我们来看下 tcp_write_xmit 的源码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/tcp_output.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">tcp_write_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonagle</span><span class="p">,</span>
<span class="ln"> 3</span>                           <span class="kt">int</span> <span class="n">push_one</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="c1">//循环获取待发送 skb
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span> 
<span class="ln"> 7</span>    <span class="p">{</span>
<span class="ln"> 8</span>        <span class="c1">//滑动窗口相关
</span><span class="ln"> 9</span><span class="c1"></span>        <span class="n">cwnd_quota</span> <span class="o">=</span> <span class="n">tcp_cwnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">10</span>        <span class="n">tcp_snd_wnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
<span class="ln">11</span>        <span class="n">tcp_mss_split_point</span><span class="p">(...);</span>
<span class="ln">12</span>        <span class="n">tso_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="p">...);</span>
<span class="ln">13</span>        <span class="p">......</span>
<span class="ln">14</span>
<span class="ln">15</span>        <span class="c1">//真正开启发送
</span><span class="ln">16</span><span class="c1"></span>        <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="ln">17</span>    <span class="p">}</span>
<span class="ln">18</span><span class="p">}</span>
</code></pre></div><p>可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/tcp_output.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_transmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clone_it</span><span class="p">,</span>
<span class="ln"> 3</span>                            <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="c1">//1.克隆新 skb 出来
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">clone_it</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7</span>        <span class="n">skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="ln"> 8</span>        <span class="p">......</span>
<span class="ln"> 9</span>    <span class="p">}</span>
<span class="ln">10</span>
<span class="ln">11</span>    <span class="c1">//2.封装 TCP 头
</span><span class="ln">12</span><span class="c1"></span>    <span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">13</span>    <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span>  <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
<span class="ln">14</span>    <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span>  <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">;</span>
<span class="ln">15</span>    <span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span>  <span class="o">=</span> <span class="p">...;</span>
<span class="ln">16</span>    <span class="n">th</span><span class="o">-&gt;</span><span class="n">urg</span>   <span class="o">=</span> <span class="p">...;</span>
<span class="ln">17</span>    <span class="p">......</span>
<span class="ln">18</span>
<span class="ln">19</span>    <span class="c1">//3.调用网络层发送接口
</span><span class="ln">20</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">fl</span><span class="p">);</span>
<span class="ln">21</span><span class="p">}</span>
</code></pre></div><p>第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？</p>
<p>是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。</p>
<p>第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_18.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_18.png" >
  
    </a>
  
  
</div>

<p>tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk-&gt;icsk_af_ops-&gt;queue_xmit()。</p>
<p>在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//net/ipv4/tcp_ipv4.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock_af_ops</span> <span class="n">ipv4_specific</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">3</span>    <span class="p">.</span><span class="n">queue_xmit</span>    <span class="o">=</span> <span class="n">ip_queue_xmit</span><span class="p">,</span>
<span class="ln">4</span>    <span class="p">.</span><span class="n">send_check</span>    <span class="o">=</span> <span class="n">tcp_v4_send_check</span><span class="p">,</span>
<span class="ln">5</span>    <span class="p">...</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div><p>自此，传输层的工作也就都完成了。数据离开了传输层，接下来将会进入到内核在网络层的实现里。</p>
<h2 id="43-网络层发送处理">4.3 网络层发送处理</h2>
<p>Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）</p>
<p>在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_19.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_19.png" >
  
    </a>
  
  
</div>

<p>我们来看网络层入口函数 ip_queue_xmit 的源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/ip_output.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">ip_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//检查 socket 中是否有缓存的路由表
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">__sk_dst_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 6</span>    <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7</span>        <span class="c1">//没有缓存则展开查找
</span><span class="ln"> 8</span><span class="c1"></span>        <span class="c1">//则查找路由项， 并缓存到 socket 中
</span><span class="ln"> 9</span><span class="c1"></span>        <span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_ports</span><span class="p">(...);</span>
<span class="ln">10</span>        <span class="n">sk_setup_caps</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
<span class="ln">11</span>    <span class="p">}</span>
<span class="ln">12</span>
<span class="ln">13</span>    <span class="c1">//为 skb 设置路由表
</span><span class="ln">14</span><span class="c1"></span>    <span class="n">skb_dst_set_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
<span class="ln">15</span>
<span class="ln">16</span>    <span class="c1">//设置 IP header
</span><span class="ln">17</span><span class="c1"></span>    <span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">18</span>    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">;</span>
<span class="ln">19</span>    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ttl</span>      <span class="o">=</span> <span class="n">ip_select_ttl</span><span class="p">(</span><span class="n">inet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
<span class="ln">20</span>    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">=</span> <span class="p">...;</span>
<span class="ln">21</span>
<span class="ln">22</span>    <span class="c1">//发送
</span><span class="ln">23</span><span class="c1"></span>    <span class="n">ip_local_out</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">24</span><span class="p">}</span>
</code></pre></div><p>ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。</p>
<p>在 Linux 上通过 route 命令可以看到你本机的路由配置。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_20.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_20.png" >
  
    </a>
  
  
</div>

<p>在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。</p>
<p>接着把路由表地址也放到 skb 里去。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/linux/skbuff.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
<span class="ln">3</span>    <span class="c1">//保存了一些路由相关信息
</span><span class="ln">4</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">_skb_refdst</span><span class="p">;</span>
<span class="ln">5</span><span class="p">}</span>
</code></pre></div><p>接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_21.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_21.png" >
  
    </a>
  
  
</div>

<p>再通过 ip_local_out 进入到下一步的处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/ip_output.c  
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">ip_local_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//执行 netfilter 过滤
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">__ip_local_out</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//开始发送数据
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
<span class="ln"> 9</span>        <span class="n">err</span> <span class="o">=</span> <span class="n">dst_output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">10</span>    <span class="p">......</span>
<span class="ln">11</span><span class="p">}</span>
</code></pre></div><p>在 ip_local_out =&gt; __ip_local_out =&gt; nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。<strong>如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加</strong>。</p>
<p>还是不多展开说，继续只聊和发送有关的过程 dst_output。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/net/dst.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dst_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="k">return</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">5</span><span class="p">}</span>
</code></pre></div><p>此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/ip_output.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">ip_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//统计
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="p">.....</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//再次交给 netfilter，完毕后回调 ip_finish_output
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="k">return</span> <span class="n">NF_HOOK_COND</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
<span class="ln"> 9</span>                        <span class="n">ip_finish_output</span><span class="p">,</span>
<span class="ln">10</span>                        <span class="o">!</span><span class="p">(</span><span class="n">IPCB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IPSKB_REROUTED</span><span class="p">));</span>
<span class="ln">11</span><span class="p">}</span>
</code></pre></div><p>在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//net/ipv4/ip_output.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_finish_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="c1">//大于 mtu 的话就要进行分片了
</span><span class="ln">5</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ip_skb_dst_mtu</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
<span class="ln">6</span>        <span class="k">return</span> <span class="n">ip_fragment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_finish_output2</span><span class="p">);</span>
<span class="ln">7</span>    <span class="k">else</span>
<span class="ln">8</span>        <span class="k">return</span> <span class="n">ip_finish_output2</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">9</span><span class="p">}</span>
</code></pre></div><p>在 ip_finish_output 中我们看到，<strong>如果数据大于 MTU 的话，是会执行分片的。</strong></p>
<blockquote>
<p>实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。</p>
</blockquote>
<p>在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/ipv4/ip_output.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_finish_output2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//根据下一跳 IP 地址查找邻居项，找不到就创建一个
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">nexthop</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span> <span class="n">rt_nexthop</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>  
<span class="ln"> 6</span>    <span class="n">neigh</span> <span class="o">=</span> <span class="n">__ipv4_neigh_lookup_noref</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">nexthop</span><span class="p">);</span>
<span class="ln"> 7</span>    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">neigh</span><span class="p">))</span>
<span class="ln"> 8</span>        <span class="n">neigh</span> <span class="o">=</span> <span class="n">__neigh_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nexthop</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="c1">//继续向下层传递
</span><span class="ln">11</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dst_neigh_output</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">12</span><span class="p">}</span>
</code></pre></div><h2 id="44-邻居子系统">4.4 邻居子系统</h2>
<p>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。</p>
<p>而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_22.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_22.png" >
  
    </a>
  
  
</div>

<p>在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_23.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_23.png" >
  
    </a>
  
  
</div>

<p>理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//include/net/arp.h
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">extern</span> <span class="k">struct</span> <span class="n">neigh_table</span> <span class="n">arp_tbl</span><span class="p">;</span>
<span class="ln"> 3</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="nf">__ipv4_neigh_lookup_noref</span><span class="p">(</span>
<span class="ln"> 4</span>    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="ln"> 5</span><span class="p">{</span>
<span class="ln"> 6</span>    <span class="k">struct</span> <span class="n">neigh_hash_table</span> <span class="o">*</span><span class="n">nht</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">arp_tbl</span><span class="p">.</span><span class="n">nht</span><span class="p">);</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="c1">//计算 hash 值，加速查找
</span><span class="ln"> 9</span><span class="c1"></span>    <span class="n">hash_val</span> <span class="o">=</span> <span class="n">arp_hashfn</span><span class="p">(......);</span>
<span class="ln">10</span>    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_buckets</span><span class="p">[</span><span class="n">hash_val</span><span class="p">]);</span>
<span class="ln">11</span>         <span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">12</span>         <span class="n">n</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">13</span>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
<span class="ln">14</span>            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="ln">15</span>    <span class="p">}</span>
<span class="ln">16</span><span class="p">}</span>
</code></pre></div><p>如果查找不到，则调用 __neigh_create 创建一个邻居。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/neighbour.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="nf">__neigh_create</span><span class="p">(......)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//申请邻居表项
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n1</span><span class="p">,</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">neigh_alloc</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//构造赋值
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">pkey</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
<span class="ln"> 9</span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
<span class="ln">10</span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">neigh_setup</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="c1">//最后添加到邻居 hashtable 中
</span><span class="ln">13</span><span class="c1"></span>    <span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_buckets</span><span class="p">[</span><span class="n">hash_val</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
<span class="ln">14</span>    <span class="p">......</span>
<span class="ln">15</span><span class="p">}</span>
</code></pre></div><p>有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。调用 dst_neigh_output 继续传递 skb。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/net/dst.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dst_neigh_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> 
<span class="ln">3</span>                                   <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln">4</span><span class="p">{</span>
<span class="ln">5</span>    <span class="p">......</span>
<span class="ln">6</span>    <span class="k">return</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">7</span><span class="p">}</span>
</code></pre></div><p>调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/neighbour.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">neigh_resolve_output</span><span class="p">(){</span>
<span class="ln"> 3</span>
<span class="ln"> 4</span>    <span class="c1">//注意：这里可能会触发 arp 请求
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_event_send</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>        <span class="c1">//neigh-&gt;ha 是 MAC 地址
</span><span class="ln"> 8</span><span class="c1"></span>        <span class="n">dev_hard_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">),</span>
<span class="ln"> 9</span>                        <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="ln">10</span>        <span class="c1">//发送
</span><span class="ln">11</span><span class="c1"></span>        <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">12</span>    <span class="p">}</span>
<span class="ln">13</span><span class="p">}</span>
</code></pre></div><p>当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。</p>
<h2 id="45网络设备子系统">4.5网络设备子系统</h2>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_24.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_24.png" >
  
    </a>
  
  
</div>

<p>邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/dev.c 
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//选择发送队列
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//获取与此队列关联的排队规则
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="c1">//如果有队列，则调用__dev_xmit_skb 继续处理数据
</span><span class="ln">11</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">12</span>        <span class="n">rc</span> <span class="o">=</span> <span class="n">__dev_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
<span class="ln">13</span>        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">14</span>    <span class="p">}</span>
<span class="ln">15</span>
<span class="ln">16</span>    <span class="c1">//没有队列的是回环设备和隧道设备
</span><span class="ln">17</span><span class="c1"></span>    <span class="p">......</span>
<span class="ln">18</span><span class="p">}</span>
</code></pre></div><p>在2网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。</p>
<p>netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx =&gt; __netdev_pick_tx。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/flow_dissector.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="n">u16</span> <span class="nf">__netdev_pick_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//获取 XPS 配置
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">new_index</span> <span class="o">=</span> <span class="n">get_xps_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//自动计算队列
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">new_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 9</span>        <span class="n">new_index</span> <span class="o">=</span> <span class="n">skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="ln">10</span><span class="p">}</span>
</code></pre></div><p>然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq pfifo_fast。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_25.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_25.png" >
  
    </a>
  
  
</div>

<p>大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/dev.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__dev_xmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
<span class="ln"> 3</span>                                 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
<span class="ln"> 4</span>                                 <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="ln"> 5</span><span class="p">{</span>
<span class="ln"> 6</span>    <span class="c1">//1.如果可以绕开排队系统
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_CAN_BYPASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8</span>        <span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9</span>        <span class="p">......</span>
<span class="ln">10</span>    <span class="p">}</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="c1">//2.正常排队
</span><span class="ln">13</span><span class="c1"></span>    <span class="k">else</span> <span class="p">{</span>
<span class="ln">14</span>
<span class="ln">15</span>        <span class="c1">//入队
</span><span class="ln">16</span><span class="c1"></span>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="ln">17</span>        <span class="c1">//开始发送
</span><span class="ln">18</span><span class="c1"></span>        <span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="ln">19</span>    <span class="p">}</span>
<span class="ln">20</span><span class="p">}</span>
</code></pre></div><p>上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。</p>
<p>先调用 q-&gt;enqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//file: net/sched/sch_generic.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">void</span> <span class="nf">__qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="kt">int</span> <span class="n">quota</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">;</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="c1">//循环从队列取出一个 skb 并发送
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">qdisc_restart</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>        <span class="c1">// 如果发生下面情况之一，则延后处理：
</span><span class="ln">10</span><span class="c1"></span>        <span class="c1">// 1. quota 用尽
</span><span class="ln">11</span><span class="c1"></span>        <span class="c1">// 2. 其他进程需要 CPU
</span><span class="ln">12</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">quota</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
<span class="ln">13</span>            <span class="c1">//将触发一次 NET_TX_SOFTIRQ 类型 softirq
</span><span class="ln">14</span><span class="c1"></span>            <span class="n">__netif_schedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="ln">15</span>            <span class="k">break</span><span class="p">;</span>
<span class="ln">16</span>        <span class="p">}</span>
<span class="ln">17</span>    <span class="p">}</span>
<span class="ln">18</span><span class="p">}</span>
</code></pre></div><p>在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。</p>
<p><strong>所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因</strong>。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。</p>
<p>我们来把精力在放到 qdisc_restart 上，继续看发送过程。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">qdisc_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="ln">2</span><span class="p">{</span>
<span class="ln">3</span>    <span class="c1">//从 qdisc 中取出要发送的 skb
</span><span class="ln">4</span><span class="c1"></span>    <span class="n">skb</span> <span class="o">=</span> <span class="n">dequeue_skb</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="ln">5</span>    <span class="p">...</span>
<span class="ln">6</span>
<span class="ln">7</span>    <span class="k">return</span> <span class="n">sch_direct_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">root_lock</span><span class="p">);</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><p>qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">sched</span><span class="o">/</span><span class="n">sch_generic</span><span class="p">.</span><span class="n">c</span>
<span class="ln">2</span><span class="kt">int</span> <span class="n">sch_direct_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
<span class="ln">3</span>                    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
<span class="ln">4</span>                    <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span><span class="p">)</span>
<span class="ln">5</span><span class="p">{</span>
<span class="ln">6</span>    <span class="c1">//调用驱动程序来发送数据
</span><span class="ln">7</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><h2 id="46软中断调度">4.6软中断调度</h2>
<p>在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。</p>
<p>软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_26.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_26.png" >
  
    </a>
  
  
</div>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/dev.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
<span class="ln"> 5</span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 6</span>    <span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="p">......</span>
<span class="ln">10</span>    <span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
<span class="ln">11</span><span class="p">}</span>
</code></pre></div><p>在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）</p>
<p>软中断的入口代码我这里也不详细扒了，我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。</p>
<p><strong>牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了</strong>。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/dev.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">net_tx_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//通过 softnet_data 获取发送队列
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">// 如果 output queue 上有 qdisc
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9</span>
<span class="ln">10</span>        <span class="c1">// 将 head 指向第一个 qdisc
</span><span class="ln">11</span><span class="c1"></span>        <span class="n">head</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
<span class="ln">12</span>
<span class="ln">13</span>        <span class="c1">//遍历 qdsics 列表
</span><span class="ln">14</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">15</span>            <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="ln">16</span>            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>
<span class="ln">17</span>
<span class="ln">18</span>            <span class="c1">//发送数据
</span><span class="ln">19</span><span class="c1"></span>            <span class="n">qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="ln">20</span>        <span class="p">}</span>
<span class="ln">21</span>    <span class="p">}</span>
<span class="ln">22</span><span class="p">}</span>
</code></pre></div><p>软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。软中断循环遍历 sd-&gt;output_queue 发送数据帧。</p>
<p>来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/net/pkt_sched.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="k">if</span> <span class="p">(</span><span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
<span class="ln">5</span>        <span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div><p>然后一样就是进入 qdisc_restart =&gt; sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。</p>
<h2 id="47-igb-网卡驱动发送">4.7 igb 网卡驱动发送</h2>
<p>我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。</p>
<p>在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_27.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_27.png" >
  
    </a>
  
  
</div>

<p>我们来看看实际的源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//net/core/dev.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="kt">int</span> <span class="nf">dev_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
<span class="ln"> 3</span>                        <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="c1">//获取设备的回调函数集合 ops
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="c1">//获取设备支持的功能列表
</span><span class="ln"> 9</span><span class="c1"></span>    <span class="n">features</span> <span class="o">=</span> <span class="n">netif_skb_features</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="ln">10</span>
<span class="ln">11</span>    <span class="c1">//调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备
</span><span class="ln">12</span><span class="c1"></span>    <span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="ln">13</span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="ln">14</span><span class="p">}</span>
</code></pre></div><p>其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//include/linux/netdevice.h
</span><span class="ln">2</span><span class="c1"></span><span class="k">struct</span> <span class="n">net_device_ops</span> <span class="p">{</span>
<span class="ln">3</span>    <span class="n">netdev_tx_t</span>  <span class="p">(</span><span class="o">*</span><span class="n">ndo_start_xmit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
<span class="ln">4</span>                                    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="ln">5</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div><p>在 igb 网卡驱动源码中，我们找到了。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">igb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">3</span>    <span class="p">.</span><span class="n">ndo_open</span>  <span class="o">=</span> <span class="n">igb_open</span><span class="p">,</span>
<span class="ln">4</span>    <span class="p">.</span><span class="n">ndo_stop</span>  <span class="o">=</span> <span class="n">igb_close</span><span class="p">,</span>
<span class="ln">5</span>    <span class="p">.</span><span class="n">ndo_start_xmit</span>  <span class="o">=</span> <span class="n">igb_xmit_frame</span><span class="p">,</span> 
<span class="ln">6</span>    <span class="p">...</span>
<span class="ln">7</span><span class="p">};</span>
</code></pre></div><p>也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。</p>
<blockquote>
<p><strong>初始化流程</strong></p>
<p>每一个驱动程序（不仅仅只是网卡驱动）会使用 module_init 向内核注册一个初始化函数，当驱动被加载时，内核会调用这个函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span>
<span class="ln"> 3</span><span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">igb_driver</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">igb_driver_name</span><span class="p">,</span>
<span class="ln"> 6</span>    <span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">igb_pci_tbl</span><span class="p">,</span>
<span class="ln"> 7</span>    <span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">igb_probe</span><span class="p">,</span>
<span class="ln"> 8</span>    <span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">igb_remove</span><span class="p">,</span>
<span class="ln"> 9</span>    <span class="p">......</span>
<span class="ln">10</span>
<span class="ln">11</span><span class="p">};</span>
<span class="ln">12</span>
<span class="ln">13</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">igb_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="ln">14</span>
<span class="ln">15</span>    <span class="p">......</span>
<span class="ln">16</span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">igb_driver</span><span class="p">);</span>
<span class="ln">17</span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">18</span>
<span class="ln">19</span><span class="p">}</span>
</code></pre></div><p>驱动的pci_register_driver调用完成后，Linux内核就知道了该驱动的相关信息，比如igb网卡驱动的igb_driver_name和igb_probe函数地址等等。当网卡设备被识别以后，内核会调用其驱动的probe方法（igb_driver的probe方法是igb_probe）。驱动probe方法执行的目的就是让设备ready，对于igb网卡，其igb_probe位于drivers/net/ethernet/intel/igb/igb_main.c下。主要执行的操作如下：</p>
<ol>
<li>
<p>启动内核</p>
</li>
<li>
<p>内核向网卡驱动调用驱动probe</p>
</li>
<li>
<p>驱动获取网卡mac地址</p>
</li>
<li>
<p>DMA初始化</p>
</li>
<li>
<p>注册ethtool实现函数</p>
</li>
<li>
<p>注册net_device_ops、netdev等变量，网卡被启动的时候会被调用</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span>
<span class="ln"> 3</span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">igb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="p">.</span><span class="n">ndo_open</span>               <span class="o">=</span> <span class="n">igb_open</span><span class="p">,</span>
<span class="ln"> 6</span>    <span class="p">.</span><span class="n">ndo_stop</span>               <span class="o">=</span> <span class="n">igb_close</span><span class="p">,</span>
<span class="ln"> 7</span>    <span class="p">.</span><span class="n">ndo_start_xmit</span>         <span class="o">=</span> <span class="n">igb_xmit_frame</span><span class="p">,</span>
<span class="ln"> 8</span>    <span class="p">.</span><span class="n">ndo_get_stats64</span>        <span class="o">=</span> <span class="n">igb_get_stats64</span><span class="p">,</span>
<span class="ln"> 9</span>    <span class="p">.</span><span class="n">ndo_set_rx_mode</span>        <span class="o">=</span> <span class="n">igb_set_rx_mode</span><span class="p">,</span>
<span class="ln">10</span>    <span class="p">.</span><span class="n">ndo_set_mac_address</span>    <span class="o">=</span> <span class="n">igb_set_mac</span><span class="p">,</span>
<span class="ln">11</span>    <span class="p">.</span><span class="n">ndo_change_mtu</span>         <span class="o">=</span> <span class="n">igb_change_mtu</span><span class="p">,</span>
<span class="ln">12</span>    <span class="p">.</span><span class="n">ndo_do_ioctl</span>           <span class="o">=</span> <span class="n">igb_ioctl</span><span class="p">,</span>
<span class="ln">13</span>
<span class="ln">14</span>    <span class="p">......</span>
<span class="ln">15</span><span class="p">}</span>
</code></pre></div></li>
<li>
<p>NAPI初始化，注册poll函数</p>
<p>对于igb网卡驱动来说，这个函数就是igb_poll,如下代码所示</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_alloc_q_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
<span class="ln"> 2</span>                              <span class="kt">int</span> <span class="n">v_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_idx</span><span class="p">,</span>
<span class="ln"> 3</span>                              <span class="kt">int</span> <span class="n">txr_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txr_idx</span><span class="p">,</span>
<span class="ln"> 4</span>                              <span class="kt">int</span> <span class="n">rxr_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rxr_idx</span><span class="p">){</span>
<span class="ln"> 5</span>    <span class="p">......</span>
<span class="ln"> 6</span>    <span class="cm">/* initialize NAPI */</span>
<span class="ln"> 7</span>    <span class="n">netif_napi_add</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span>
<span class="ln"> 8</span>                   <span class="n">igb_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="ln"> 9</span>
<span class="ln">10</span><span class="p">}</span>
</code></pre></div></li>
</ol>
</blockquote>
<p>所以在上面网络设备层调用 ops-&gt;ndo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">igb_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
<span class="ln"> 3</span>                                  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="ln"> 4</span><span class="p">{</span>
<span class="ln"> 5</span>    <span class="p">......</span>
<span class="ln"> 6</span>    <span class="k">return</span> <span class="n">igb_xmit_frame_ring</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">igb_tx_queue_mapping</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
<span class="ln"> 7</span><span class="p">}</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span><span class="n">netdev_tx_t</span> <span class="nf">igb_xmit_frame_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
<span class="ln">10</span>                                <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="ln">11</span><span class="p">{</span>
<span class="ln">12</span>    <span class="c1">//获取TX Queue 中下一个可用缓冲区信息
</span><span class="ln">13</span><span class="c1"></span>    <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">];</span>
<span class="ln">14</span>    <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
<span class="ln">15</span>    <span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="ln">16</span>    <span class="n">first</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">17</span>
<span class="ln">18</span>    <span class="c1">//igb_tx_map 函数准备给设备发送的数据。
</span><span class="ln">19</span><span class="c1"></span>    <span class="n">igb_tx_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">);</span>
<span class="ln">20</span><span class="p">}</span>
</code></pre></div><p>在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_28.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_28.png" >
  
    </a>
  
  
</div>

<p>igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
<span class="ln"> 3</span>                       <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
<span class="ln"> 4</span>                       <span class="k">const</span> <span class="n">u8</span> <span class="n">hdr_len</span><span class="p">)</span>
<span class="ln"> 5</span><span class="p">{</span>
<span class="ln"> 6</span>    <span class="c1">//获取下一个可用描述符指针
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="c1">//为 skb-&gt;data 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据
</span><span class="ln">10</span><span class="c1"></span>    <span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="c1">//遍历该数据包的所有分片,为 skb 的每个分片生成有效映射
</span><span class="ln">13</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">];;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">14</span>
<span class="ln">15</span>        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
<span class="ln">16</span>        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="p">...;</span>
<span class="ln">17</span>        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">18</span>    <span class="p">}</span>
<span class="ln">19</span>
<span class="ln">20</span>    <span class="c1">//设置最后一个descriptor
</span><span class="ln">21</span><span class="c1"></span>    <span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">size</span> <span class="o">|</span> <span class="n">IGB_TXD_DCMD</span><span class="p">;</span>
<span class="ln">22</span>    <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_type</span><span class="p">);</span>
<span class="ln">23</span>
<span class="ln">24</span>    <span class="cm">/* Force memory writes to complete before letting h/w know there
</span><span class="ln">25</span><span class="cm">    * are new descriptors to fetch
</span><span class="ln">26</span><span class="cm">    */</span>
<span class="ln">27</span>    <span class="n">wmb</span><span class="p">();</span>
<span class="ln">28</span><span class="p">}</span>
</code></pre></div><p>当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。</p>
<h2 id="48-发送完成硬中断">4.8 发送完成硬中断</h2>
<p>当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。</p>
<p>在发送完成硬中断里，会执行 RingBuffer 内存的清理工作，如图。</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_29.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_29.png" >
  
    </a>
  
  
</div>

<p>再回头看一下硬中断触发软中断的源码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">____napi_schedule</span><span class="p">(...){</span>
<span class="ln">3</span>    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
<span class="ln">4</span>    <span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
<span class="ln">5</span><span class="p">}</span>
</code></pre></div><p>这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，<strong>从硬中断触发的软中断都是 NET_RX_SOFTIRQ</strong>。这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。</p>
<p>好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln">2</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="ln">3</span><span class="p">{</span>
<span class="ln">4</span>    <span class="c1">//performs the transmit completion operations
</span><span class="ln">5</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
<span class="ln">6</span>        <span class="n">clean_complete</span> <span class="o">=</span> <span class="n">igb_clean_tx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
<span class="ln">7</span>    <span class="p">...</span>
<span class="ln">8</span><span class="p">}</span>
</code></pre></div><p>我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">//drivers/net/ethernet/intel/igb/igb_main.c
</span><span class="ln"> 2</span><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">igb_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="ln"> 3</span><span class="p">{</span>
<span class="ln"> 4</span>    <span class="c1">//free the skb
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="c1">//clear tx_buffer data
</span><span class="ln"> 8</span><span class="c1"></span>    <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 9</span>    <span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">10</span>
<span class="ln">11</span>    <span class="c1">// clear last DMA location and unmap remaining buffers */
</span><span class="ln">12</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">tx_desc</span> <span class="o">!=</span> <span class="n">eop_desc</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">13</span>    <span class="p">}</span>
<span class="ln">14</span><span class="p">}</span>
</code></pre></div><p>无非就是清理了 skb，解除了 DMA 映射等等。到了这一步，传输才算是基本完成了。</p>
<p>为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。</p>
<h1 id="5总结">5总结</h1>
<p>用一张图总结一下整个发送过程</p>
<p>了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。</p>
<blockquote>
<p>1<strong>我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？</strong></p>
</blockquote>
<p>在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。</p>
<p>只有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。</p>
<p>所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。</p>
<blockquote>
<p>2<strong>在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？</strong></p>
</blockquote>
<p>之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的：</p>


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

<div class="figure center fig-100" >
  
    <a class="fancybox" href="https://yangyang48.github.io/tcpip/send/send_30.png" data-fancybox-group="">
  
    <img class="fig-img" src="https://yangyang48.github.io/tcpip/send/send_30.png" >
  
    </a>
  
  
</div>

<p>经过今天的源码分析，发现这个问题的原因有两个。</p>
<p>第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。</p>
<p>第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。</p>
<p>综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。</p>
<blockquote>
<p>3<strong>发送网络数据的时候都涉及到哪些内存拷贝操作？</strong></p>
</blockquote>
<p>这里的内存拷贝，我们只特指待发送数据的内存拷贝。</p>
<p>第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。</p>
<p>第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。</p>
<p>第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。</p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/linux/">Linux</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/tcp/ip%E5%8D%8F%E8%AE%AE%E6%A0%88/">TCP/IP协议栈</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E5%8F%91%E9%80%81/">发送</a>

  <a class="tag tag--primary tag--small" href="https://yangyang48.github.io/tags/%E6%BA%90%E7%A0%81/">源码</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2023/02/c-typeof/" data-tooltip="c&#43;&#43; typeof">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2023/01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3selinux%E9%82%A3%E7%82%B9%E4%BA%8B/" data-tooltip="一文带你了解SElinux那点事">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
		
		<div class="post-comment main-content-wrap">
		
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'mwl8M1aQzLnRE6JIpIY3sgE5-9Nh9j0Va',
        appKey: 'mPGr6GMC0BuzAKkxinnd0IAr',
        notify:  true , 
        verify:  false , 
        avatar:'retro', 
        placeholder: '欢迎各位宝宝留言~',
        visitor:  true 
    });
  </script>

		</div>
        <footer id="footer" class="main-content-wrap">
  
  
  
  <span class="copyrights">
    &copy; 2023 Yang Ju. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2023/02/c-typeof/" data-tooltip="c&#43;&#43; typeof">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yangyang48.github.io/2023/01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3selinux%E9%82%A3%E7%82%B9%E4%BA%8B/" data-tooltip="一文带你了解SElinux那点事">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fyangyang48.github.io%2F2023%2F02%2Flinux%25E7%259A%2584tcp%2Fip%25E5%258D%258F%25E8%25AE%25AE%25E6%25A0%2588%25E5%258F%2591%25E9%2580%2581%25E8%25BF%2587%25E7%25A8%258B%2F">
          <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fyangyang48.github.io%2F2023%2F02%2Flinux%25E7%259A%2584tcp%2Fip%25E5%258D%258F%25E8%25AE%25AE%25E6%25A0%2588%25E5%258F%2591%25E9%2580%2581%25E8%25BF%2587%25E7%25A8%258B%2F">
          <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2Fyangyang48.github.io%2F2023%2F02%2Flinux%25E7%259A%2584tcp%2Fip%25E5%258D%258F%25E8%25AE%25AE%25E6%25A0%2588%25E5%258F%2591%25E9%2580%2581%25E8%25BF%2587%25E7%25A8%258B%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://yangyang48.github.io/thumb/20210711204627625.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">Yang Ju</h4>
    
      <div id="about-card-bio">Nanjing University of Science and Technology</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Development Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        NanJing,China
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://yangyang48.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://yangyang48.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


  
    <script src="https://yangyang48.github.io/js/copy-to-clipboard.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/yangyang48.github.io\/2023\/02\/linux%E7%9A%84tcp\/ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B\/';
          
            this.page.identifier = '\/2023\/02\/linux%E7%9A%84tcp\/ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

