<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 欢迎来到我的博客~</title>
    <link>https://yangyang48.github.io/post/</link>
    <description>Recent content in Posts on 欢迎来到我的博客~</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yangyang48.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式</title>
      <link>https://yangyang48.github.io/2021/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;设计模式代表了最佳的实践，是软件开发人员在软件开发过程中面临的一般问题的解决方案。笔者初衷用于对整体架构设计理解并记录，毕竟最好的学习就是输出。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode hot100</title>
      <link>https://yangyang48.github.io/2021/07/leetcode-hot100/</link>
      <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/leetcode-hot100/</guid>
      <description>&lt;p&gt;LeetCode是目前主流的算法刷题题库，尤其在实际开发过程中，可以做一些算法数据结构上的优化。笔者初衷用于边刷题边记录，毕竟最好的学习就是输出。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>linux2 NDK交叉编译</title>
      <link>https://yangyang48.github.io/2022/03/linux2-ndk%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/03/linux2-ndk%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>&lt;p&gt;在当前编译平台下，编译出来的程序能运行在另一种目标平台上，但是编译平台本身却不能运行该程序。而我们在linux服务器编译的库可以直接在Android工程中编译。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ByteBuffer使用</title>
      <link>https://yangyang48.github.io/2022/02/bytebuffer%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/02/bytebuffer%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;ByteBuffer，一个字节缓冲区。我们通常通过这类缓冲区(Buffer)在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parcel1 Parcel和Parcelable源码分析</title>
      <link>https://yangyang48.github.io/2022/02/parcel1-parcel%E5%92%8Cparcelable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2022/02/parcel1-parcel%E5%92%8Cparcelable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;Intent数据会作为Parcel被存储在Binder事务缓冲区中的对象进行传输。Parcel作为Android底层IPC通信的基础，熟悉Parcel作为了解Binder的第一步。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>并发编程3 阻塞队列和线程池</title>
      <link>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;p&gt;在并发编程中，频繁的创建和销毁线程非常影响处理的效率，而且会使得线程抢占系统资源从而导致阻塞。这时候就需要线程池的帮助，线程池的创建离不开阻塞队列。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>并发编程2 CAS基本原理</title>
      <link>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-cas%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2-cas%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;CAS(compare and Swap)是由硬件实现的。CAS可以将read- modify - write这类的操作转换为原子操作。jdk1.5之后引入CAS利用CPU原语保证线程操作的原子性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>并发编程1 java并发基础知识</title>
      <link>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1-java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;p&gt;这块java并发基础知识主要是更全面的认识线程，了解线程，包括线程启动的二种方式、线程的生命周期、破坏死锁的四种方式和ThreadLocal。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式之代理模式</title>
      <link>https://yangyang48.github.io/2021/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;比如你在澡堂洗完澡需要搓澡服务，你会联系大堂经理给你安排比较有名搓澡技师，这个时候大堂经理就会在预备的技师里面选一个给你服务。这种模式就是代理模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AIDL源码分析</title>
      <link>https://yangyang48.github.io/2021/11/aidl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/aidl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;aidl一种android接口描述语言，本文主要是对.aidl文件自动生成的.java文件的具体源码进行分析，描述AIDL生成的java类细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android注解</title>
      <link>https://yangyang48.github.io/2021/11/android%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/android%E6%B3%A8%E8%A7%A3/</guid>
      <description>&lt;p&gt;在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。这就是注解，比如@Override，@Deprecated。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ThreadLocal之初出茅庐</title>
      <link>https://yangyang48.github.io/2021/11/threadlocal%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/11/threadlocal%E4%B9%8B%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</guid>
      <description>&lt;p&gt;我们使用ThreadLocal能够解决线程局部变量统一定义问题，多线程数据不能共享的问题，使得每一个线程单独维护自己线程内的变量值（set、get、remove）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android数据存储</title>
      <link>https://yangyang48.github.io/2021/10/android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/10/android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid>
      <description>&lt;p&gt;如果我需要在音视频app中的登录界面记住账号密码，并且在音视频的传输过程中，将编码后的mp4文件和aac文件保存，这个就需要用到Android数据存储。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AIDL使用</title>
      <link>https://yangyang48.github.io/2021/08/aidl%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 29 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/aidl%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;第三方移动支付（银联/菜信等）使用微信/支付宝支付过程中，出现支付宝或者微信支付界面。
从一个APP到另一个APP调用的过程，就需要今天的主角AIDL来实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recyclerview使用</title>
      <link>https://yangyang48.github.io/2021/08/recyclerview%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/recyclerview%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;RecyclerView，一个强大的控件，既支持纵向滚动，又支持横向滚动。
应用场景非常广泛，简单说ListView可以做的它可以做，ListView不支持的横向它也可以做。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler1-消息传递机制</title>
      <link>https://yangyang48.github.io/2021/08/handler1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;Handler是一个优秀的内存共享方案。其内存管理和设计思路相当完整。
通过Handler来通知UI组件更新或者是处理对应消息。那么Handler消息机制是什么？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler2 Thread</title>
      <link>https://yangyang48.github.io/2021/08/handler2-thread/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler2-thread/</guid>
      <description>&lt;p&gt;Android是基于事件驱动的，即所有的不管是Activity、Service生命周期都是通过handler事件驱动的。
那么Handler内部的线程是如何管理而且还能够保证安全。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler3 同步屏障</title>
      <link>https://yangyang48.github.io/2021/08/handler3-%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler3-%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</guid>
      <description>&lt;p&gt;学习Handler之后，通常会出现同步屏障的字样。MessageQueue管理优先级队列的过程中，如果消息存在一种“紧急”消息，
需要更高的优先级处理，这个时候就需要同步屏障。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler4 HandlerThread</title>
      <link>https://yangyang48.github.io/2021/08/handler4-handlerthread/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler4-handlerthread/</guid>
      <description>&lt;p&gt;开发中我们需要去执行多个任务，且要求按顺序执行。如果使用多线程，有多个任务就多创建几个线程实现，这时候可能出现线程同步的问题。
如果需要管理这些线程，可以考虑使用HandlerThread。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler5 IntentService</title>
      <link>https://yangyang48.github.io/2021/08/handler5-intentservice/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/handler5-intentservice/</guid>
      <description>&lt;p&gt;在Android开发中，需要在后台执行异步耗时请求，而且存在很多这种请求，那么怎么管理这些请求。
如果不断的创建线程，本身就非常耗性能，且不易管理，这个时候可以考虑使用IntentService。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一篇文章搞定广播</title>
      <link>https://yangyang48.github.io/2021/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9A%E5%B9%BF%E6%92%AD/</link>
      <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9A%E5%B9%BF%E6%92%AD/</guid>
      <description>&lt;p&gt;BroadcastReceiver，Android四大组件之一。
用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RTMP封包</title>
      <link>https://yangyang48.github.io/2021/07/rtmp%E5%B0%81%E5%8C%85/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/rtmp%E5%B0%81%E5%8C%85/</guid>
      <description>&lt;p&gt;RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。
基于TCP的一个协议族，包括RTMP、RTMPT、RTMPS、RTMPE等多个协议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一篇文章读懂unicode</title>
      <link>https://yangyang48.github.io/2021/07/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82unicode/</link>
      <pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82unicode/</guid>
      <description>&lt;p&gt;很多宝宝对unicode的基础概念，unicode、utf-8、char、GB2312傻傻分不清楚。
这篇文章带你揭开unicode神秘的面纱。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Leetcode1</title>
      <link>https://yangyang48.github.io/2021/07/leetcode1/</link>
      <pubDate>Sun, 11 Jul 2021 17:12:24 +0800</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/leetcode1/</guid>
      <description>Z字形变换 问题描述 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 &amp;ldquo;LEETCODEISHIRING&amp;rdquo; 行数为 3 时，排列如下：(这里用#表示空格加以区分)
 L # C # I # R # E T O E S I I G E # D # H # N #
 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;LCIRETOESIIGEDHN&amp;rdquo;。
请你实现这个将字符串进行指定行数变换的函数：
 string convert(string s, int numRows);
 示例 1:  输入: s = &amp;ldquo;LEETCODEISHIRING&amp;rdquo;, numRows = 3 输出: &amp;ldquo;LCIRETOESIIGEDHN&amp;rdquo;
 示例 2:  输入: &amp;ldquo;bbbbb&amp;rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。
 示例 3：  输入: s = &amp;ldquo;LEETCODEISHIRING&amp;rdquo;, numRows = 4 输出: &amp;ldquo;LDREOEIIECIHNTSG&amp;rdquo; 解释: L # # D # # R E # O E # I I E C # I H # N T # # S # # G</description>
    </item>
    
    <item>
      <title>first commit</title>
      <link>https://yangyang48.github.io/2021/07/first-commit/</link>
      <pubDate>Sun, 11 Jul 2021 15:50:29 +0800</pubDate>
      
      <guid>https://yangyang48.github.io/2021/07/first-commit/</guid>
      <description>unicode 在开始这个问题之前首先提出几个问题，希望读者能带着这几个问题去看这篇文章
问题1 一个汉字究竟占几个字节？
问题2 我在网页上能看到一些外文像韩文日文或者特殊符号，自己却打不出来？
问题3 如何理解C/C++中的char、wchar_t 、char16_t和char32_t这几种类型？
起源 计算机只能处理数字，不能处理文本，那么对计算机操作文本就需要进行一定的编码。
计算机通过设计8位（1个字节）的二进制编码进行操作文本，因为计算机不是中国发明的，一开始计算机语言是26英文字母、数字和一些符号，2^8-1=255个编码已经完全能够适应，这就是早起的ASCII编码。
然而随着世界的发展，并且各个国家都有自己的语言，上述的编码已经不够用了，各个国家自己制定自己的文字的编码规则。中国大陆制定了GB2312，日本就是JIT标准，中国香港，中国台湾对应的是BIG5标准。
这里的GB2312，采用两个字节，因此编码范围就从0xA1A1 -0xFEFE，这个范围可以表示23901个汉字，但实际上里面包含6763个汉字和682个符号。这种方法好处就是和ASCII不会发生冲突，并且能够实现英文和汉字同时显示。
BIG5，香港和台湾用的比较多，繁体，范围： 0xA140 - 0xF9FE, 0xA1A1 - 0xF9FE，每个字由两个字节组成，其第一字节编码范围为0xA1~0xF9，第二字节编码范围为0x40-0x7E与0xA1-0xFE，总计收入13868个字(包括5401个常用字、7652 个次常用字、7个扩充字、以及808个各式符号)。
其他国家也会出现类似的问题，那么每个国家的语言就都成“方言”了，只能处理自己国家的文本。很显然，这样做不利于国际的沟通和交流。那么，这个时候unicode就出来大显身手了。unicode通过数字来处理字符，保证前256个字符的同时，而且使得各个国家各个字符都互相兼容。
在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符，那么总的可表示的字符即为2^16-1=65535。那么65535个字符就完全能把世界上语言都装进去吗，回答是不能。因为还有其他的十六个平面，我们常用的就是基本文本平面BMP，也叫零号平面。
文本平面的概念就是Unicode中的一个编码区段。编码从U+0000至U+FFFF，总共有这样的17个平面。
上图表示为第零平面，看起来跟元素周期表类似。有不同的颜色分类，还有未开发未使用的格子。其中每个写着数字的格子代表256个码点，不同的颜色对应不同的文本含义，详见下述阐释，具体可以参照百度百科。 黑 = 拉丁文字及符号 浅蓝 = Linguistic scripts 蓝 = 其他欧洲文字 橘 = Middle Eastern and SW Asian scripts 浅橘 = 非洲文字 绿 = 南亚文字 紫 = 东南亚文字 红 = 东亚文字 浅红 = 中日韩汉字 黄 = Aboriginal scripts 紫红 = 符号 深灰 = Diacritics 浅灰 = UTF-16surrogates and private use 蓝青 = Miscellaneous characters 白 = 未使用</description>
    </item>
    
  </channel>
</rss>
